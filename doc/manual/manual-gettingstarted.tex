\chapter{Getting started}
\section{Downloading the code}

The \akantu source code can be requested using the form accessible at the URL
\url{http://lsms.epfl.ch/akantu}.  There, you will be asked to accept the LGPL
license terms.

\section{Compiling Akantu}

Akantu is a \code{cmake} project, so to configure it you can either follow the usual way:
\begin{command}
  > cd akantu
  > mkdir build
  > cd build
  > ccmake ..
  [ Set the options that you need ]
  > make
  > make install
\end{command}

Or, you can use a tool  we added to help you. You can just use the
given \code{Makefile} that handles the \code{cmake} configuration

\begin{command}
  > cd akantu
  > make config
  > make
  > make install
\end{command}

\section{Writing a \code{main} function\label{sect:common:main}}

First of all, \akantu needs to be initialized.  There is a memory
management included in the core library which allows a correct
allocation and de-allocation of vectors, structures and
objects. Moreover, in parallel computations the initialization
procedure can perform the communication setup. This is achieved by
 a pair of functions (\code{initialize} and \code{finalize})
that are used as follows:
\begin{cpp}
int main(int argc, char *argv[])
{
  akantu::initialize(argc, argv);

  // your code
  ...

  akantu::finalize();
}
\end{cpp}
The \code{initialize} function takes the program parameters which
can be interpreted by \akantu and given to the underlying libraries (\eg MPI).

\section{Creating and loading a mesh\label{sect:common:mesh}}

\akantu supports meshes generated with Gmsh~\cite{gmsh2009}, a free
software available at \url{http://geuz.org/gmsh/}. A detailed
documentation can be found at this URL, so this manual will not provide
Gmsh usage directions. Gmsh outputs meshes in \code{.msh} format that can be read
by \akantu. In order to import a mesh, it is necessary to create
a \code{Mesh} object through the following function calls:
\begin{cpp}
  UInt spatial_dimension = 2;
  Mesh mesh(spatial_dimension);
\end{cpp}
The only parameter that has to be specified by the user is the spatial
dimension of the problem. Now it is possible to read a \code{.msh} file with
a \code{read()} function of the mesh.
\begin{cpp}
  mesh.read("square.msh", mesh);
\end{cpp}
This function tries to guess the reader to use based on the extension of the file.

The mesh can also be wrote to a file with the \code{write()} method.
\begin{cpp}
  mesh.write("square_modified.msh", mesh);
\end{cpp}

For now, \akantu supports only meshes generated Gmsh or by
DIANA (\url{http://tnodiana.com}). If the \code{read()} or \code{write()}
functions cannot guess the file type, an optional parameter can be specified
to force the use of a particular reader/writer.

\begin{center}
  \begin{tabular}{lll}
    \toprule
    Mesh Type & \multicolumn{1}{c}{Key} & Capabilities\\
    \midrule
    Gmsh & \code{\_miot\_gmsh} & read/write\\
    Diana & \code{\_miot\_diana} & read\\
    \bottomrule
  \end{tabular}
\end{center}


\section{Using \code{Vectors}}

Data in \akantu can be stored in the data structures implemented by
the \code{Vector} class. In its most basic usage the \code{Vector} class
implemented in \akantu is similar to the \code{vector} class of
the Standard Template Library (STL) for C++. A simple \code{Vector}
containing a sequence of \code{nb\_element} values can be generated with:
\begin{cpp}
  Vector<type> example_vector(nb_element);
\end{cpp}
where \code{type} usually is \code{Real}, \code{UInt} or
\code{bool}. Each value is associated to an index, so that data can be
accessed by typing:

\begin{cpp}
  type & val = example_vector(index)
\end{cpp}

\code{Vectors} can also contain a sequence of values for each
index. In that case the number of components of each sequence must be
specified during \code{Vector} creation.  For example, if we want to
create a \code{Vector} to store the coordinates (sequence of three
values) of ten nodes, the appropriate code is the following:
\begin{cpp}
  UInt nb_nodes = 10;
  UInt spatial_dimension = 3;

  Vector<Real> position(nb_nodes, spatial_dimension);
\end{cpp}
In this case the $x$ position of node number 8 will be given by
\code{position(7, 0)} (in C++, numbering starts from 0). If the number of
components for the sequence is not specified, the default value of 1 is used.

It is very common in \akantu to loop over vectors to perform a specific
operation. This ranges from geometric calculation on nodal quantities
to tensor algebra (in constitutive laws for example).

The \code{Vector} object provides iterators
in order to make the writing of loops easier and enhance readability.
For instance, a loop over the nodal coordinates can be performed as:
\begin{cpp}
  //accessing the nodal coordinates Vector
  Vector<Real> & nodes = mesh.getNodes();

  //creating the iterators
  Vector<Real>::iterator<types::RVector> it  = nodes.begin(spatial_dimension);
  Vector<Real>::iterator<types::RVector> end = nodes.end(spatial_dimension);

  for (; it != end; ++it){
    RVector & coords = (*it);

    //do what you need
    ....
  }
\end{cpp}
In this example, each \code{RVector} is a geometrical vector of size \code{spatial\_dimension}
and the iteration is conveniently performed by the \code{Vector} iterator \code{it}.

The \code{Vector} object is intensively used to store tensor values.  In that
case it should be specified that the returned object type is a matrix when
constructing the iterator. This is done when calling the \code{begin} function. For
instance, assuming that we have a \code{Vector} storing stresses, we can loop
over the stored tensors by:

\begin{cpp}
  //creating the iterators
  Vector<Real>::iterator<types::RMatrix> it  = stresses.begin(spatial_dimension,spatial_dimension);
  Vector<Real>::iterator<types::RMatrix> end = stresses.end(spatial_dimension,spatial_dimension);

  for (; it != end; ++it){
    Matrix<Real> & stress = (*it);

    //do what you need
    ....
  }
\end{cpp}
In this last example, the \code{Matrix} objects have dimension
\code{spatial\_dimension} $\times$ \code{spatial\_dimension}.
The light objects \code{Matrix} and \code{RVector} can be used and combined
to do most common linear algebra.

In general, a mesh consists of several kinds of elements. Consequently, the
amount of data to be stored can differ for each element type. The straightforward
example is the connectivity array, \ie the sequences of nodes belonging to
each element. In order to easily manage this kind of data, a
particular data structure called \code{ByElementTypeVector} is available.
This structure is just a group of \code{Vector}, each associated to an element
type. The following code can retrieve the \code{ByElementTypeVector}
which stores the connectivity arrays for a mesh:
\begin{cpp}
  ByElementTypeVector<UInt> & connectivities = mesh.getConnectivities();
\end{cpp}
Then the specific vector associated to a given element type can be
obtained by
\begin{cpp}
  Vector<UInt> & connectivity_triangle = connectivities(_triangle_3);
\end{cpp}
where the first order 3-node triangular element was used in the presented
piece of code.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "manual"
%%% End:
