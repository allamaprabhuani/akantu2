\chapter{Getting started}
\section{Downloading the code}
SVN URL to get \akantu :
\begin{command}
  > svn co svn+ssh://username@intranet-lsms.epfl.ch/space/repositories/SimulPack/akantu/trunk akantu
\end{command}

\section{Compiling Akantu}
\begin{command}
  > cd akantu
  > mkdir build
  > cd build
  > ccmake <path to akantu sources>
\end{command}

Set the options that you need

\begin{command}
  > make
  > make install
\end{command}

\section{Creating and loading a mesh\label{sect:common:mesh}}

\akantu supports meshes generated with Gmsh~\cite{gmsh}, a free
software that is available in the
internet\footnote{http://geuz.org/gmsh/}. Its documentation can be
found on the website, so in this manual no directions for Gmsh usage
will be provided. Gmsh outputs meshes in .msh format, that can be read
by \akantu. In order to import a mesh, first it is necessary to create
a \textit{Mesh} object through the following commands:
\begin{cpp}
  UInt spatial_dimension = 2;
  Mesh mesh(spatial_dimension);
\end{cpp}
The only parameter that has to be specified by the user is the spatial
dimension of the problem. Now it is possible to read a .msh file with
a \textit{MeshIOMSH} object that takes care of mesh input and
output. This step is carried out by:
\begin{cpp}
  MeshIOMSH mesh_io;
  mesh_io.read("square.msh", mesh);
\end{cpp}
where first the \textit{MeshIOMSH} object is created and then it is
used to read the .msh file. The mesh file name and \textit{Mesh}
object where to store it must be specified by the user. The
\textit{MeshIOMSH} object is able to write mesh files as well. This
feature can be useful for example when a mesh is modified during a
simulation. The \textit{write} method takes care of it and can be used
as:
\begin{cpp}
  mesh_io.write("square_modified.msh", mesh);
\end{cpp}
that works exactly like the \textit{read} method.

\akantu supports also meshes generated by
DIANA\footnote{http://tnodiana.com}, but only in reading mode. The
same procedure that has just been described applies. The only
difference is that the \textit{MeshIODiana} object should be used
instead of the \textit{MeshIOMSH} one. Additional mesh readers can be
introduced in \akantu by coding new \textit{MeshIO} objects.

\subsection{Using \textit{Vectors}}

Data in \akantu can be stored in data containers called
\textit{Vectors}. In its most basic usage the \textit{Vector} class
implemented in \akantu is very similar to the \textit{vector} class of
the Standard Template Library (STL) for C++. A simple \textit{Vector}
containing a sequence of a certain number \texttt{nb\_element} of
values can be generated as:
\begin{cpp}
  Vector<type> example_vector(nb_element);
\end{cpp}
where \texttt{type} usually is \texttt{Real}, \texttt{UInt} or
\texttt{bool}. Each value is associated to an index, so data can be
accessed by simply typing
\texttt{example\_vector(index)}. \textit{Vectors} can also contain a
sequence of values for every index. The only thing to do is specifying
the number of components of each sequence when the vector is
created. For example if we want to create a \textit{Vector} to store
the coordinates (sequences of three values) of ten nodes, the code to
write is the following:
\begin{cpp}
  UInt nb_nodes = 10;
  UInt spatial_dimension = 3;

  Vector<Real> position(nb_nodes, spatial_dimension);
\end{cpp}
In this case the $x$ position of node number 8 will be given by
\texttt{position(7, 0)} (in C++ numbering is starting from 0 and not
1). If the number of components for the sequences is not specified, a
default value of 1 is used.

Often, when a mesh consists of several kinds of elements, the same
category of data has to be stored for each element type. An example if
this is the connectivity, namely the sequences of nodes belonging to
each element. In order to easily manage this kind of data, a
particular data structure called \textit{ByElementTypeVector} was
coded. It is just a group of \textit{Vectors} associated to an element
type. The following code is creating a \textit{ByElementTypeVector}
object:
\begin{cpp}
  ByElementTypeVector<UInt> connectivity;
\end{cpp}
where \texttt{UInt} can be substituted by any other kind of
variable. Before being able to use \texttt{connectivity} it is
necessary to initialize it, that is allocating the appropriate memory
according to the number of elements in the mesh. This operation can be
automatically carried out