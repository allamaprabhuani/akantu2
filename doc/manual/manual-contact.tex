

\chapter{Contact}

\section{Implicit contact solver}

The contact formulation corresponds to the Augmented-Lagrangian method \cite{Laursen:2002}, which seeks to minimize the following energy functional between two bodies with contact interface $ \Gamma_c^{\left( 1 \right)} $: 
\begin{equation} \label{eq:functinal} 
  \Pi^{al} \left( \boldsymbol u, \lambda_N \right) := \sum_{i=1}^2 \Pi ^{\left( i \right) } ( \boldsymbol u ^{\left( i \right) }  ) + \int_{\Gamma_c^{\left( 1 \right) } } \left[ \frac{1}{2 \epsilon_N } \left< \lambda_N + \epsilon_N g \right>^ 2 - \frac{1}{2 \epsilon_N} \lambda^2_N \right] \, d\Gamma,
\end{equation}
where $ \Pi^{\left( i \right) } $ correspondes to the energy functional of the $ i $th body in contact, which is a function of the displacement field $\boldsymbol u$ and the lagrangian multiplier $\lambda_N$. In the equation above, $\epsilon_N$ is a penalty parameter,  $g$ the contact gap function, and $\left< \cdot \right>$ the Macaulay bracket.

The solution procedure seeks to make the equation above stationary with respect to both $\boldsymbol u$ and $\lambda_N$:
\begin{equation}
\begin{aligned}
 0 &= D_{\boldsymbol u} \Pi^{al} \cdot \boldsymbol w = G^{int,ext} \left( \boldsymbol u, \boldsymbol w \right) + \int_{\Gamma_c^{\left( 1 \right) } } \left< \lambda_N + \epsilon_N g \right> \delta g  \, d\Gamma  \qquad  \forall \boldsymbol w \in \mathcal{V} \\
0 &= D_{ \lambda} \Pi^{al} \cdot q_N  = \frac{1}{\epsilon_N} \int_{\Gamma_c^{\left( 1 \right) } } \left[ \left< \lambda_N + \epsilon_N g \right> - \lambda_N \right] q_N  \, d\Gamma  \qquad  \forall q_N \in \mathcal{M}
\end{aligned}
\end{equation}

A solution is then found by using Uzawa's method, for which we solve for $ \boldsymbol u ^ {\left( k \right) }$, with $ \lambda_N^{\left( k \right)}$ fixed:
\begin{equation}
 G^{int,ext} ( \boldsymbol u ^ {\left( k \right) }, \boldsymbol w ) + \int_{\Gamma_c^{\left( 1 \right) } } \left< \lambda_N^ {\left( k \right) } + \epsilon_N g( \boldsymbol u ^ {\left( k \right) } )  \right> \delta g  \, d\Gamma = 0 \qquad \forall \boldsymbol w \in \mathcal{V},
 \end{equation}

followed by an update of the multipliers on $\Gamma_c ^ {\left( 1 \right) }$: 
\begin{equation}
\lambda _N ^ {\left( k+1 \right) } = \left< \lambda_N ^ {\left( k \right) } + \epsilon_N g ( \boldsymbol u ^ {\left( k \right) } ) \right>.
\end{equation}


It is worth noting that the results of the implicit contact resolution depend largely on the choice of the penalty parameter $ \epsilon_N $. Depending on this parameter, the computational time needed to obtain a converged solution can be increased dramatically, or a convergence solution could not even be obtained at all.

The code provides a flag that allows the user to rely on an automatic value of $ \epsilon_N $ for each slave node. Yet, this value should be used as a reference only, since for some problems it is actually overestimated and convergence cannot be obtained.


\subsection{Implementation} 

In \akantu, the object that handles the implicit contact can be found in \code{implicit\_contact\_manager.hh}.
The object that handles the implicit contact resolution stage is the class template 
\begin{cpp}
template <int dim, class model_type> struct ContactData;
\end{cpp}
This object takes the command line parameters during construction, which can be used to set-up the behavior during contact resolution. The object can take the following parameters (default values in brackets):

\begin{tabular}{lrl}
  -e & [auto] & Penalty parameter for Augmented-Lagrangian formulation \\
  -alpha & [1] & Multiplier for values of the penalty parameter\\
 -utol & [0.001] & Tolerance used for multipliers in the Uzawa method\\
 -ntol &[0.001]& Tolerance used in the Newton-Raphson inner convergence loop\\
 -usteps &[100]&  Maximum number of steps allowed in the Uzawa loop\\
 -nsteps & [100]&  Maximum number of steps allowed in the Newton-Raphson loop\\
\end{tabular} \\


Also, the following flags can be given to the command line


\begin{tabular}{ll}
 -dump&          Dumping within Newton iterations \\
 -v&             Verbose output
\end{tabular} \\



The \code{ContactData} object stores the state of the contact mechanics simulation. The state is contained within the following variables:

\begin{tabular}{ll}
 \code{sm\_}  & Slave-master map \\
 \code{multipliers\_} & Lagrange multiplier map \\
 \code{areas\_} & slave areas map \\
 \code{penalty\_} & penalty parameter map \\
 \code{gaps\_} & gap function map \\
 \code{model\_} & Reference to solid mechanics model \\
 \code{multiplier\_dumper\_} & Structures used to dump multipliers \\
  \code{pressure\_dumper\_} & Structures used to dump pressure \\
 \code{options\_} & Options map \\
 \code{flags\_} & Flags map \\
 \code{uiter\_}, \code{niter\_} & Uzawa and Newton iteration counters
\end{tabular} \\


The interface of the \code{ContactData} object contains three functions to solve for each contact step, which is overloaded depending on the parameters passed. Their signatures are as follows


\begin{cpp}
void solveContactStep();

void solveContactStep(search_type *search);

template <class PostAssemblyFunctor>
void solveContactStep(search_type *search, const PostAssemblyFunctor& fn);
}
\end{cpp}

The second function allows the user to provide a pointer to an object that is used to search slave-master pairs. This can be done, for example, when due to the deformed configuration current slave-master pairs are no longer valid.
The last function in the snippet above allows the user to provide a functor that will be called after the assembly of the contact contributions to the stiffness matrix and the force vector. The last takes place within the function \code{computeTangentAndResidual()}.




