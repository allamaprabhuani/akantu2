

\chapter{Contact}

\section{Implicit contact solver}

The contact formulation corresponds to the Augmented-Lagrangian method \cite{Laursen:2002}, which seeks to minimize the following energy functional between two bodies with contact interface $ \Gamma_c^{\left( 1 \right)} $: 
\begin{equation} \label{eq:functinal} 
  \Pi^{al} \left( \boldsymbol u, \lambda_N \right) := \sum_{i=1}^2 \Pi ^{\left( i \right) } ( \boldsymbol u ^{\left( i \right) }  ) + \int_{\Gamma_c^{\left( 1 \right) } } \left[ \frac{1}{2 \epsilon_N } \left< \lambda_N + \epsilon_N g \right>^ 2 - \frac{1}{2 \epsilon_N} \lambda^2_N \right] \, d\Gamma,
\end{equation}
where $ \Pi^{\left( i \right) } $ correspondes to the energy functional of the $ i $th body in contact, which is a function of the displacement field $\boldsymbol u$ and the lagrangian multiplier $\lambda_N$. In the equation above, $\epsilon_N$ is a penalty parameter,  $g$ the contact gap function, and $\left< \cdot \right>$ the Macaulay bracket.

The solution procedure seeks to make the equation above stationary with respect to both $\boldsymbol u$ and $\lambda_N$:
\begin{equation}
 0 = D_{\boldsymbol u} \Pi^{al} \cdot \boldsymbol w = G^{int,ext} \left( \boldsymbol u, \boldsymbol w \right) + \int_{\Gamma_c^{\left( 1 \right) } } \left< \lambda_N + \epsilon_N g \right> \delta g  \, d\Gamma  \qquad  \forall \boldsymbol w \in \mathcal{V}
\end{equation}
\begin{equation}  0 = D_{ \lambda} \Pi^{al} \cdot q_N  = \frac{1}{\epsilon_N} \int_{\Gamma_c^{\left( 1 \right) } } \left[ \left< \lambda_N + \epsilon_N g \right> - \lambda_N \right] q_N  \, d\Gamma  \qquad  \forall q_N \in \mathcal{M}
\end{equation}

A solution is then found by using Uzawa's method, for which we solve for $ \boldsymbol u ^ {\left( k \right) }$, with $ \lambda_N^{\left( k \right)}$ fixed:

\begin{equation}
 G^{int,ext} ( \boldsymbol u ^ {\left( k \right) }, \boldsymbol w ) + \int_{\Gamma_c^{\left( 1 \right) } } \left< \lambda_N^ {\left( k \right) } + \epsilon_N g( \boldsymbol u ^ {\left( k \right) } )  \right> \delta g  \, d\Gamma = 0 \qquad \forall \boldsymbol w \in \mathcal{V},
 \end{equation}

%followed by an update of the multipliers on $\Gamma_c ^ {\left( 1 \right) }$: 
%
%$$\lambda _N ^ {\left( k+1 \right) } = \left< \lambda_N ^ {\left( k \right) } + \epsilon_N g ( \boldsymbol u ^ {\left( k \right) } ) \right>.$$
%
%It is worth noting that the results of the implicit contact resolution depend largely on the choice of the penalty parameter $ \epsilon_N $. Depending on this parameter, the computational time needed to obtain a converged solution can be increased dramatically, or a convergence solution could not even be obtained at all.
%
%The code provides a flag that allows the user to rely on an automatic value of $ \epsilon_N $ for each slave node. Yet, this value should be used as a reference only, since for some problems it is actually overestimated and convergence cannot be obtained.
%
%
%=== Implementation ===
%
%In Akantu, the object that handles the implicit contact can be found in [source:trunk/src/model/implicit_contact_manager.hh implicit_contact_manager.hh].
%
%The object that handles the implicit contact resolution stage is the class template 
%{{{#!cpp
%template <int dim, class model_type> struct ContactData;
%}}}
%This object takes the command line parameters during construction, which can be used to set-up the behavior during contact resolution. The object can take the following parameters (default values in brackets):
%
% -e     [auto]:: Penalty parameter for Augmented-Lagrangian formulation
% -alpha  ![1]:: Multiplier for values of the penalty parameter
% -utol [0.001]:: Tolerance used for multipliers in the Uzawa method
% -ntol [0.001]:: Tolerance used in the Newton-Raphson inner convergence loop
% -usteps ![100]::  Maximum number of steps allowed in the Uzawa loop
% -nsteps ![100]::  Maximum number of steps allowed in the Newton-Raphson loop
%Also, the following flags can be given to the command line
% -dump::          Dumping within Newton iterations
% -v::             Verbose output
%
%
%The {{{ContactData}}} object stores the state of the contact mechanics simulation. The state is contained within the following variables:
%
% -sm_ :: Slave-master map
% -multipliers_, areas_, penalty_, gaps_ :: Maps for Lagrange multipliers, slave areas, penalty parameters and gap functions
% -model_:: Reference to solid mechanics model
% -multiplier_dumper_, pressure_dumper_ :: Structures used to dump results
% -options_ :: Options map
% -flags_ :: Flags map
% -uiter_, niter_ :: Uzawa and Newton iteration counters
%
%
%The interface of the {{{ContactData}}} object contains three functions to solve for each contact step, which is overloaded depending on the parameters passed. Their signatures are as follows
%
%{{{#!cpp
%void solveContactStep();
%
%void solveContactStep(search_type *search);
%
%template <class PostAssemblyFunctor>
%void solveContactStep(search_type *search, const PostAssemblyFunctor& fn);
%}}}
%
%The second function allows the user to provide a pointer to an object that is used to search slave-master pairs. This can be done, for example, when due to the deformed configuration current slave-master pairs are no longer valid.
%The last function in the snippet above allows the user to provide a functor that will be called after the assembly of the contact contributions to the stiffness matrix and the force vector. The last takes place within the function {{{computeTangentAndResidual()}}}.




