/**
 * @file   mesh_io_msh.cc
 * @author Nicolas Richart <nicolas.richart@epfl.ch>
 * @date   Fri Jun 18 11:36:35 2010
 *
 * @brief  Read/Write for MSH files
 *
 * @section LICENSE
 *
 * <insert lisence here>
 *
 */

/* -------------------------------------------------------------------------- */

__BEGIN_MYFEM__

/* -------------------------------------------------------------------------- */
typedef enum {
  _msh_line_1        = 1,   // 2-node line.
  _msh_triangle_1    = 2,   // 3-node triangle.
  _msh_quadrangle_1  = 3,   // 4-node quadrangle.
  _msh_tetrahedron_1 = 4,   // 4-node tetrahedron.
  _msh_hexaedron_1   = 5,   // 8-node hexahedron.
  _msh_prism_1       = 6,   // 6-node prism.
  _msh_pyramid_1     = 7,   // 5-node pyramid.
  _msh_line_2        = 8,   // 3-node second order line
  _msh_triangle_2    = 9,   // 6-node second order triangle
  _msh_quadrangle_2  = 10,  // 9-node second order quadrangle
  _msh_tetrahedron_2 = 11,  // 10-node second order tetrahedron
  _msh_hexaedron_2   = 12,  // 27-node second order hexahedron
  _msh_prism_2       = 13,  // 18-node second order prism
  _msh_pyramid_2     = 14,  // 14-node second order pyramid
  _msh_point         = 15   // 1-node point.
} _msh_element_type_t;

/* -------------------------------------------------------------------------- */
static int __READ_ORDER[5][10] = {
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // _not_defined
  { 0, 1, 2, 0, 0, 0, 0, 0, 0, 0 }, // TRIANGLE 1
  { 0, 1, 2, 3, 4, 5, 6, 0, 0, 0 }, // TRIANGLE 2
  { 0, 1, 2, 3, 4, 0, 0, 0, 0, 0 }, // TETRA 1
  { 0, 1, 2, 3, 4, 5, 6, 7, 9, 8 }, // TETRA 2
};

static int __MSH_NODES_PER_ELEM[16] =
  { 0, // element types began at 1
    2, 3, 4, 4,  8,  6,  5,
    3, 6, 9, 10, 27, 18, 14,
    1 };

static ElementType __MSH_TO_ADLIB_ELEMENT_TYPES[15] =
  { _not_defined, ADLIB_TRIANGLE1, _not_defined, ADLIB_TETRA1, _not_defined, _not_defined, _not_defined, // 1st order
    _not_defined, ADLIB_TRIANGLE2, _not_defined, ADLIB_TETRA2, _not_defined, _not_defined, _not_defined, // 2nd order
    _not_defined };

static int __ADLIB_TO_MSH_ELEMENT_TYPES[7] =
  { 2,	// ADLIB_TRIANGLE1
    9,  // ADLIB_TRIANGLE2
    4,	// ADLIB_TETRA1
    11, // ADLIB_TETRA2
  };

static int __PRESUMED_DIMENSION[16] =
  { 0, // element types began at 1
    1, 2, 2, 3, 3, 3, 3,
    1, 2, 2, 3, 3, 3, 3,
    0 };

/* -------------------------------------------------------------------------- */
#include "mesh_io_msh.hh"

/* -------------------------------------------------------------------------- */
void MeshIOMSH::read(const std::string & filename, const Mesh & mesh) {
  
}

/* -------------------------------------------------------------------------- */
void MeshIOMSH::write(const std::string & filename, const Mesh & mesh) {
  
}

__END_MYFEM__


/* -------------------------------------------------------------------------- */
/* Reader/writer for msh files generated by gmsh                              */
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
extern double * coordinates;
extern int * connectivity;
extern int * element_type;

extern int * element_material;

extern int nodes;
extern int elements;

extern int nodes_element;
extern int spatial_dimension;

extern int surf_elements;           /* current number of surface elements (total)*/
extern int nodes_surf_elements;     /* number of nodes/surface_element */
extern int number_faces;            /* number of faces */
extern int *surf_elem_face;         /* element face connection */
extern int *surf_elem_connectivity; /* surface element connectivity */


/* -------------------------------------------------------------------------- */
static unsigned char __format = 1;
static unsigned int __first_node_number = 1;
static unsigned int __last_node_number  = 1;
static unsigned int __current_line = 0;

/* -------------------------------------------------------------------------- */
static void read_node(const char * line, int node, int fill_material, int read_surfaces);
static void read_element(const char * line, int node, int fill_material, int read_surfaces);

/* -----------------------------------------------------------------------------
   Version (Legacy) 1.0

   $NOD
   number-of-nodes
   node-number x-coord y-coord z-coord
   ...
   $ENDNOD
   $ELM
   number-of-elements
   elm-number elm-type reg-phys reg-elem number-of-nodes node-number-list
   ...
   $ENDELM
   -----------------------------------------------------------------------------
   Version 2.1

   $MeshFormat
   version-number file-type data-size
   $EndMeshFormat
   $Nodes
   number-of-nodes
   node-number x-coord y-coord z-coord
   ...
   $EndNodes
   $Elements
   number-of-elements
   elm-number elm-type number-of-tags < tag > ... node-number-list
   ...
   $EndElements
   $PhysicalNames
   number-of-names
   physical-dimension physical-number "physical-name"
   ...
   $EndPhysicalNames
   $NodeData
   number-of-string-tags
   < "string-tag" >
   ...
   number-of-real-tags
   < real-tag >
   ...
   number-of-integer-tags
   < integer-tag >
   ...
   node-number value ...
   ...
   $EndNodeData
   $ElementData
   number-of-string-tags
   < "string-tag" >
   ...
   number-of-real-tags
   < real-tag >
   ...
   number-of-integer-tags
   < integer-tag >
   ...
   elm-number value ...
   ...
   $EndElementData
   $ElementNodeData
   number-of-string-tags
   < "string-tag" >
   ...
   number-of-real-tags
   < real-tag >
   ...
   number-of-integer-tags
   < integer-tag >
   ...
   elm-number number-of-nodes-per-element value ...
   ...
   $ElementEndNodeData

   -----------------------------------------------------------------------------
   elem-type

   1:  2-node line.
   2:  3-node triangle.
   3:  4-node quadrangle.
   4:  4-node tetrahedron.
   5:  8-node hexahedron.
   6:  6-node prism.
   7:  5-node pyramid.
   8:  3-node second order line
   9:  6-node second order triangle
   10: 9-node second order quadrangle
   11: 10-node second order tetrahedron
   12: 27-node second order hexahedron
   13: 18-node second order prism
   14: 14-node second order pyramid
   15: 1-node point.
   16: 8-node second order quadrangle
   17: 20-node second order hexahedron
   18: 15-node second order prism
   19: 13-node second order pyramid
   20: 9-node third order incomplete triangle
   21: 10-node third order triangle
   22: 12-node fourth order incomplete triangle
   23: 15-node fourth order triangle
   24: 15-node fifth order incomplete triangle
   25: 21-node fifth order complete triangle
   26: 4-node third order edge
   27: 5-node fourth order edge
   28: 6-node fifth order edge
   29: 20-node third order tetrahedron
   30: 35-node fourth order tetrahedron
   31: 56-node fifth order tetrahedron
   -------------------------------------------------------------------------- */

/* \todo reader assume that the index space of nodes is contigus without missing
   indexes */

/* -------------------------------------------------------------------------- */
void write_mesh_msh(const char * filename, int write_material, int write_surfaces) {
  FILE * fp = fopen(filename, "w");
  int i, j;

  fprintf(fp, "$MeshFormat\n");
  fprintf(fp, "2 0 8\n");
  fprintf(fp, "$EndMeshFormat\n");

  fprintf(fp, "$Nodes\n");
  fprintf(fp, "%d\n", nodes);
  for(i = 0; i < nodes; ++i) {
    int offset = i*spatial_dimension;
    fprintf(fp, "%d", i+1);
    for(j = 0; j < spatial_dimension; ++j) {
      fprintf(fp, " %E", coordinates[offset + j]);
    }

    if(spatial_dimension == 2)
      fprintf(fp, " %E", 0.);

    fprintf(fp, "\n");
  }
  fprintf(fp, "$EndNodes\n");

  fprintf(fp, "$Elements\n");
  int real_elements = elements;
  if(write_surfaces)
    real_elements += surf_elements;

  fprintf(fp, "%d\n", real_elements);
  if(write_surfaces) {
    for(i = 0; i < surf_elements; ++i) {
      int offset = i * nodes_element;
      int reg_phys = surf_elem_face[i];
      int elem_type;
      if(spatial_dimension == 2) {
	if(nodes_surf_elements == 2)
	  elem_type = ADLIB_LINE1;
	else { if (nodes_surf_elements == 3)
	    elem_type = ADLIB_LINE2;
	}
      } else {
	if(nodes_surf_elements == 3)
	  elem_type = ADLIB_TRIANGLE1;
	else { if (nodes_surf_elements == 6)
	    elem_type = ADLIB_TRIANGLE2;
	}
      }

      fprintf(fp, "%d %d 3 %d 0 0",
	      i+1,
	      __ADLIB_TO_MSH_ELEMENT_TYPES[elem_type],
	      reg_phys);

      for(j = 0; j < nodes_element; ++j) {
	fprintf(fp, " %d", surf_elem_connectivity[offset + j]);
      }
      fprintf(fp, "\n");
    }
  }

  for(i = 0; i < elements; ++i) {
    int offset = (i) * nodes_element;
    int reg_phys = write_material ? element_material[i] : 0;
    fprintf(fp, "%d %d 3 %d 0 0",
	    i+1 + (real_elements - elements), // if not write_surface
	                                      // real_elements == elements
	    __ADLIB_TO_MSH_ELEMENT_TYPES[element_type[i]],
	    reg_phys);

    for(j = 0; j < nodes_element; ++j) {
      fprintf(fp, " %d", connectivity[offset + j]);
    }
    fprintf(fp, "\n");
  }

  fprintf(fp, "$EndElements\n");
}

/* -------------------------------------------------------------------------- */

void load_mesh_msh(const char * filename, int dim, int fill_material, int read_surfaces) {
  FILE * fp = fopen(filename, "r");
#define MAX_READ 512
  char line[MAX_READ];
  // size_t len = 0;
  // ssize_t read;
  unsigned int  line_to_read = 0;

  typedef enum {
    not_defined_block = 0,
    node_block = 1,
    element_block = 2,
    header_block
  } block_kind_t;

  block_kind_t block_kind = not_defined_block; // 1 Node  block, 2 element block,
					       // \todo add physical information
  char beginend_block = 1;
  unsigned int  block_size = 0;

  void(*read_func)(const char*, int, int, int)  = NULL;

  if(fp == NULL) {
    fprintf(stderr, "ERROR: canot open file %s.\n", filename);
    exit(EXIT_FAILURE);
  }

  spatial_dimension = dim;

  while(fgets(line, MAX_READ, fp) != NULL) {
    __current_line++;
    if(beginend_block == 1) {
      beginend_block = 0;
      if(line[0] != '$') {
	fprintf(stderr, "ERROR: Malformed file - was expecting the begining of a block (line %d).\n", __current_line);
	line_to_read = 1;
	block_kind = block_kind == not_defined_block ? node_block : element_block;
	__format = 2;
      }

      block_kind = not_defined_block;
      line_to_read = 0;
      block_size = 0;

      /* if((strstr(line, "$End") != NULL) || (strstr(line, "$END") != NULL)) { */
      /* } */

      if(strstr(line, "$MeshFormat") != NULL) {
	block_kind = header_block;
	line_to_read = 1;
	block_size = 1;
	__format = 2;
      }

      if((strstr(line, "$Nodes") != NULL) || (strstr(line, "$NOD") != NULL)) {
	block_kind = node_block;
	line_to_read = 1;
	block_size = 0;
      }

      if((strstr(line, "$Elements") != NULL) || (strstr(line, "$ELM") != NULL)) {
	block_kind = element_block;
	line_to_read = 1;
	block_size = 0;
	nodes_element = 0;
	if (read_surfaces) {
	  nodes_surf_elements = 0;
	  number_faces = 0;
	}
      }
    } else if((block_size == 0) && (line_to_read == 1)) { // first line of a block
							  // containing the size of
							  // the block
      sscanf(line, "%d", &line_to_read);
      block_size = line_to_read;

      switch(block_kind) {
      case node_block: {
	nodes = block_size;
	coordinates = malloc(block_size * spatial_dimension * sizeof(double));
	read_func = read_node;
	break;
      }
      case element_block: {
	elements = block_size;
	if (read_surfaces) surf_elements = block_size;
	read_func = read_element;
	break;
      }
      case header_block: {
	break;
      }
      default:
	read_func = NULL;
	fprintf(stderr, "WARNING: unsuported block_kind (%d) in msh reader (line %d).\n", block_kind, __current_line);
      }
    } else { // reading the block
      if(read_func != NULL) {
	read_func(line, block_size - line_to_read, fill_material, read_surfaces);
      }
      line_to_read--;
    }

    if (line_to_read == 0) beginend_block = 1;
  }

  // if there is less element than predicted...
  connectivity = realloc(connectivity, elements*nodes_element*sizeof(int));
  element_type = realloc(element_type, elements*sizeof(int));
  if(fill_material)
    element_material = realloc(element_material, elements*sizeof(int));

  if(read_surfaces) {
    surf_elem_face         = realloc(surf_elem_face, surf_elements * sizeof(int));
    surf_elem_connectivity = realloc(surf_elem_connectivity, surf_elements * nodes_surf_elements * sizeof(int));
  }
  //if(line) free(line);
  fclose(fp);
}

/* -------------------------------------------------------------------------- */

static void read_node(const char * line, int node, int fill_material, int read_surfaces) {
  int index;
  double coord[3];
  int offset = node * spatial_dimension;

  sscanf(line, "%d %lf %lf %lf", &index,
	 &coord[0],
	 &coord[1],
	 &coord[2]);

  __first_node_number = __first_node_number < index ? __first_node_number : index;
  __last_node_number  = __last_node_number  > index ? __last_node_number  : index;

  {
    unsigned int i;
    for(i = 0; i < spatial_dimension; ++i)
      coordinates[offset + i] = coord[i];
  }
}

/* -------------------------------------------------------------------------- */

static void read_element(const char * line, int element, int fill_material, int read_surfaces) {
  typedef enum {
    type_surface,
    type_element,
    type_not_defined
  } element_type_t;

  static int _nb_surface_element_ = 0;
  static int _nb_element_ = 0;
  static int _nb_not_read_ = 0;
  static int _reg_elem_ = 0;
  element_type_t current_element_type = type_not_defined;

  char * tmp_line = malloc((strlen(line) + 1)*sizeof(char));
  strcpy(tmp_line, line);

  char * token = strtok(tmp_line, " ");
  //int elem_index = atoi(token);

  token = strtok(NULL, " ");
  _msh_element_type_t type = atoi(token);
  int real_type = 0;
  char allocate_surfaces = 0;
  char allocate_elements = 0;

  // configuration depending on the element type
  switch(type)
    {
    case _msh_line_1 :
    case _msh_line_2 :
    case _msh_triangle_1 :
    case _msh_triangle_2 :
    case _msh_tetrahedron_1 :
    case _msh_tetrahedron_2 : {
      real_type = __MSH_TO_ADLIB_ELEMENT_TYPES[type-1];
      if(__PRESUMED_DIMENSION[type] == spatial_dimension) {
	allocate_elements = (nodes_element == 0);
	nodes_element = __MSH_NODES_PER_ELEM[type];
	_nb_element_++;
	current_element_type = type_element;
	if(read_surfaces) surf_elements--;
      } else if(__PRESUMED_DIMENSION[type] == spatial_dimension - 1) {
	_nb_surface_element_++;
	elements--;
	if(read_surfaces) {
	  allocate_surfaces = (nodes_surf_elements == 0);
	  nodes_surf_elements = __MSH_NODES_PER_ELEM[type];
	  current_element_type = type_surface;
	} else {
	  fprintf(stderr,
		  "WARNING: trying to read triangles in dimension different from 2D (line %d).\n",
		  __current_line);
	  return;
	}
      }
      break;
    }
    default:
      fprintf(stderr,
	      "WARNING: msh-element type %d not supported (line %d).\n",
	      type,
	      __current_line);
      _nb_not_read_++;
      elements--;
      if(read_surfaces) surf_elements--;
      return;
    }

  int real_element = current_element_type == type_element ?
    element - _nb_not_read_ - _nb_surface_element_ :
    element - _nb_not_read_ - _nb_element_;


  // Allocation
  if(allocate_surfaces) {
    surf_elem_face         = malloc(surf_elements * sizeof(int));
    surf_elem_connectivity = malloc(surf_elements * nodes_surf_elements * sizeof(int));
  }

  if(allocate_elements) {
    connectivity = malloc(elements * nodes_element * sizeof(int));
    element_type = malloc(elements * sizeof(int));
    if(fill_material)
      element_material = malloc(elements * sizeof(int));
  }

  // setting element type
  if (current_element_type == type_element) element_type[real_element] = real_type;

  // reading physical and geometry inforamtion
  token = strtok(NULL, " ");
  int reg_phys = 0;
  int reg_elem = 0;

  if(__format == 2) {
    int num_of_tags = atoi(token);
    if(num_of_tags >= 1) {
      token = strtok(NULL, " ");
      reg_phys = atoi(token);
//      num_of_tags--;
//      token = strtok(NULL, " ");
      reg_elem = reg_phys;//atoi(token);
      num_of_tags--;
      { int i; for(i = 0; i < num_of_tags; i++) token = strtok(NULL, " "); }
    }
  } else {
    reg_phys = atoi(token);
    reg_elem = reg_phys;
    token = strtok(NULL, " "); // reg-elem
    token = strtok(NULL, " "); // number-of-nodes
  }


  if(fill_material && (current_element_type == type_element)) element_material[real_element] = reg_phys;
  if(read_surfaces && (current_element_type == type_surface)) {
    if (reg_elem != _reg_elem_) {
      number_faces ++; //we assume that faces are contigus in the msh file
      _reg_elem_ = reg_elem;
    }
    surf_elem_face[real_element] = reg_elem;
  }

  // reading connectivities
  {
    int i;
    int current_nodes_elem = current_element_type == type_element ? nodes_element : nodes_surf_elements;
    int offset = real_element*current_nodes_elem;

    for(i = 0; i < current_nodes_elem; i++) {
      token = strtok(NULL, " ");
      int index = atoi(token);

      assert(index <= __last_node_number);
      index = index - __first_node_number + 1;

      int element_index = offset + __READ_ORDER[real_type - 1][i];

      if(current_element_type == type_element)
	connectivity[element_index] = index;
      else if (read_surfaces)
	surf_elem_connectivity[element_index] = index;
    }
  }
}

/* -------------------------------------------------------------------------- */
