common/solver_callback.cc:  this->sc_dof_manager = &dof_manager;
common/non_local_toolbox/non_local_manager_inline_impl.hh:    this->createNeighborhood(weight_func_id, neighborhood);
common/non_local_toolbox/neighborhood_base.cc:      spatial_dimension(this->model.getMesh().getSpatialDimension()) {
common/non_local_toolbox/neighborhood_base.cc:  this->registerDataAccessor(*this);
common/non_local_toolbox/neighborhood_base.cc:  this->createGrid();
common/non_local_toolbox/neighborhood_base.cc:  Mesh & mesh = this->model.getMesh();
common/non_local_toolbox/neighborhood_base.cc:  spacing.fill(this->neighborhood_radius * safety_factor);
common/non_local_toolbox/neighborhood_base.cc:      auto q1_coords = this->quad_coordinates.get(q1);
common/non_local_toolbox/neighborhood_base.cc:          auto q2_coords = this->quad_coordinates.get(q2);
common/non_local_toolbox/neighborhood_base.cc:          if (distance <= this->neighborhood_radius + Math::getTolerance() &&
common/non_local_toolbox/neighborhood_base.cc:        auto && coords = this->quad_coordinates.get(q);
common/non_local_toolbox/neighborhood_base.cc:      auto && q1_coords = this->quad_coordinates.get(q1);
common/non_local_toolbox/neighborhood_base.cc:          auto && q2_coords = this->quad_coordinates.get(q2);
common/non_local_toolbox/neighborhood_base.cc:  auto & fem = this->model.getFEEngine();
common/non_local_toolbox/neighborhood_base.cc:    for (auto && [q1, q2] : this->pair_list.at(ghost_type)) {
common/non_local_toolbox/neighborhood_base.cc:  this->grid_synchronizer->onElementsRemoved(element_list, new_numbering,
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:  this->weight_function = std::make_unique<WeightFunction>(manager);
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:  this->registerSubSection(ParserType::_weight_function, "weight_parameter",
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:  this->weight_function->setRadius(this->neighborhood_radius);
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:      this->non_local_manager.getVolumes();
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:    auto && jacobians = this->non_local_manager.getJacobians();
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:      auto && q1_coord = this->quad_coordinates.get(q1);
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:      auto && q2_coord = this->quad_coordinates.get(q2);
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:      weight(0) = q2_wJ * (*this->weight_function)(r, q1, q2);
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:        weight(1) = q1_wJ * (*this->weight_function)(r, q2, q1);
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:  if (this->weight_function->getUpdateRate() and
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:      (this->non_local_manager.getNbStressCalls() %
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:           this->weight_function->getUpdateRate() ==
common/non_local_toolbox/non_local_neighborhood_tmpl.hh:    this->computeWeights();
common/non_local_toolbox/non_local_manager.cc:    this->weight_function_types[name] = section;
common/non_local_toolbox/non_local_manager.cc:  this->callback = &callback;
common/non_local_toolbox/non_local_manager.cc:  volumes.initialize(this->model.getFEEngine(),
common/non_local_toolbox/non_local_manager.cc:  AKANTU_DEBUG_ASSERT(this->callback,
common/non_local_toolbox/non_local_manager.cc:  this->callback->insertIntegrationPointsInNeighborhoods(_not_ghost);
common/non_local_toolbox/non_local_manager.cc:  auto & mesh = this->model.getMesh();
common/non_local_toolbox/non_local_manager.cc:  this->createNeighborhoodSynchronizers();
common/non_local_toolbox/non_local_manager.cc:  this->callback->insertIntegrationPointsInNeighborhoods(_ghost);
common/non_local_toolbox/non_local_manager.cc:  FEEngine & fee = this->model.getFEEngine();
common/non_local_toolbox/non_local_manager.cc:  this->updatePairLists();
common/non_local_toolbox/non_local_manager.cc:  this->cleanupExtraGhostElements(); // nb_ghost_protected);
common/non_local_toolbox/non_local_manager.cc:  this->callback->initializeNonLocal();
common/non_local_toolbox/non_local_manager.cc:  this->setJacobians(fee, _ek_regular);
common/non_local_toolbox/non_local_manager.cc:  this->initNonLocalVariables();
common/non_local_toolbox/non_local_manager.cc:  this->computeWeights();
common/non_local_toolbox/non_local_manager.cc:  auto weight_func_it = this->weight_function_types.find(weight_func);
common/non_local_toolbox/non_local_manager.cc:          this->integration_points_positions,
common/non_local_toolbox/non_local_manager.cc:  Vector<Real> grid_center(this->spatial_dimension);
common/non_local_toolbox/non_local_manager.cc:  Vector<Real> spacing(this->spatial_dimension);
common/non_local_toolbox/non_local_manager.cc:      this->spatial_dimension, spacing, grid_center);
common/non_local_toolbox/non_local_manager.cc:          this->model.getMesh(), *dummy_grid,
common/non_local_toolbox/non_local_manager.cc:          std::string(this->id + ":" + neighborhood_id + ":grid_synchronizer"),
common/non_local_toolbox/non_local_manager.cc:    this->computeWeights();
common/non_local_toolbox/non_local_manager.cc:  this->updateWeightFunctionInternals();
common/non_local_toolbox/non_local_manager.cc:  this->volumes.zero();
common/non_local_toolbox/non_local_manager.cc:      this->model.getFEEngine(), _nb_component = spatial_dimension,
common/non_local_toolbox/non_local_manager.cc:  this->model.getFEEngine().computeIntegrationPointsCoordinates(
common/non_local_toolbox/non_local_manager.cc:        variable_name, nl_variable_name, this->id, nb_component);
common/non_local_toolbox/non_local_manager.cc:  auto it = this->weight_function_internals.find(field_name);
common/non_local_toolbox/non_local_manager.cc:        std::make_unique<ElementTypeMapReal>(field_name, this->id);
common/non_local_toolbox/non_local_manager.cc:  for (auto & pair : this->weight_function_internals) {
common/non_local_toolbox/non_local_manager.cc:      this->callback->updateLocalInternal(internals, ghost_type, _ek_regular);
common/non_local_toolbox/non_local_manager.cc:    variable.non_local.initialize(this->model.getFEEngine(),
common/non_local_toolbox/non_local_manager.cc:      this->callback->updateLocalInternal(variable.local, ghost_type,
common/non_local_toolbox/non_local_manager.cc:  this->volumes.zero();
common/non_local_toolbox/non_local_manager.cc:  this->averageInternals(_not_ghost);
common/non_local_toolbox/non_local_manager.cc:  this->averageInternals(_ghost);
common/non_local_toolbox/non_local_manager.cc:      this->callback->updateNonLocalInternal(variable.non_local, ghost_type,
common/non_local_toolbox/non_local_manager.cc:  this->callback->computeNonLocalContribution(_not_ghost);
common/non_local_toolbox/non_local_manager.cc:  ++this->compute_stress_calls;
common/non_local_toolbox/non_local_manager.cc:  FEEngine & fee = this->model.getFEEngine();
common/non_local_toolbox/non_local_manager.cc:  this->resizeElementTypeMap(1, volumes, model.getFEEngine());
common/non_local_toolbox/non_local_manager.cc:  this->resizeElementTypeMap(spatial_dimension, integration_points_positions,
common/non_local_toolbox/non_local_manager.cc:  auto & mesh = this->model.getMesh();
common/non_local_toolbox/non_local_manager.cc:  auto nb_quadrature_points = this->model.getNbIntegrationPoints(elements);
common/non_local_toolbox/non_local_manager.cc:      it->second->local, buffer, elements, this->model.getFEEngine());
common/non_local_toolbox/non_local_manager.cc:      it->second->local, buffer, elements, this->model.getFEEngine());
common/non_local_toolbox/base_weight_function_inline_impl.hh:  this->R2 = this->R * this->R;
common/non_local_toolbox/base_weight_function_inline_impl.hh:  this->R = radius;
common/non_local_toolbox/base_weight_function_inline_impl.hh:  this->R2 = this->R * this->R;
common/non_local_toolbox/base_weight_function_inline_impl.hh:  if (r <= this->R) {
common/non_local_toolbox/base_weight_function_inline_impl.hh:    Real alpha = (1. - r * r / this->R2);
common/non_local_toolbox/non_local_neighborhood_base.cc:  this->registerParam("radius", neighborhood_radius, 100.,
common/non_local_toolbox/non_local_neighborhood_base.cc:  this->is_creating_grid = true;
common/non_local_toolbox/non_local_neighborhood_base.cc:  this->grid_synchronizer = std::make_unique<GridSynchronizer>(
common/non_local_toolbox/non_local_neighborhood_base.cc:      this->model.getMesh(), *spatial_grid, *this,
common/non_local_toolbox/non_local_neighborhood_base.cc:  this->is_creating_grid = false;
common/non_local_toolbox/non_local_neighborhood_base.cc:    auto & pair_list = this->pair_list.at(ghost_type);
common/non_local_toolbox/non_local_neighborhood_base.cc:  auto & mesh = this->model.getMesh();
common/non_local_toolbox/non_local_neighborhood_base.cc:  this->non_local_variables.insert(id);
common/non_local_toolbox/base_weight_function.hh:    this->registerParam("update_rate", update_rate, Int(1), _pat_parsmod,
common/non_local_toolbox/non_local_neighborhood_inline_impl.hh:      size += this->non_local_manager.getNbData(elements, variable_id);
common/non_local_toolbox/non_local_neighborhood_inline_impl.hh:  size += this->weight_function->getNbData(elements, tag);
common/non_local_toolbox/non_local_neighborhood_inline_impl.hh:      this->non_local_manager.packData(buffer, elements, variable_id);
common/non_local_toolbox/non_local_neighborhood_inline_impl.hh:  this->weight_function->packData(buffer, elements, tag);
common/non_local_toolbox/non_local_neighborhood_inline_impl.hh:      this->non_local_manager.unpackData(buffer, elements, variable_id);
common/non_local_toolbox/non_local_neighborhood_inline_impl.hh:  this->weight_function->unpackData(buffer, elements, tag);
common/non_local_toolbox/neighborhood_base_inline_impl.hh:  this->spatial_grid->insert(quad, coords);
common/non_linear_solver/non_linear_solver.cc:  this->registerParam("type", this->non_linear_solver_type, _pat_parsable,
common/non_linear_solver/non_linear_solver.cc:  if (this->supported_type.find(this->non_linear_solver_type) ==
common/non_linear_solver/non_linear_solver.cc:          this->supported_type.end() and
common/non_linear_solver/non_linear_solver.cc:      this->non_linear_solver_type != NonLinearSolverType::_auto) {
common/non_linear_solver/non_linear_solver.cc:                     << this->non_linear_solver_type
common/non_linear_solver/non_linear_solver.cc:                     << this->id << "!");
common/non_linear_solver/non_linear_solver.cc:    this->_dof_manager.zeroResidual();
common/non_linear_solver/non_linear_solver.cc:    this->_dof_manager.assembleMatMulDOFsToResidual("K", -1.);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion_inline_impl.hh:  auto nb_quadrature_points = this->model.getNbIntegrationPoints(elements);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion_inline_impl.hh:        criterion, buffer, elements, this->model.getFEEngine());
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion_inline_impl.hh:        criterion, buffer, elements, this->model.getFEEngine());
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->registerParam("radius", neighborhood_radius, 100.,
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  auto & mesh = this->model.getMesh();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    auto new_size = this->quad_coordinates(type, ghost_type).size();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    this->is_highest.alloc(new_size, 1, type, ghost_type, true);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    this->criterion.alloc(new_size, 1, type, ghost_type, 1.);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    auto new_size = this->quad_coordinates(type, ghost_type).size();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    this->criterion.alloc(new_size, 1, type, ghost_type, true);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->parseSection(section_neighborhood);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->createGrid();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->insertAllQuads(_not_ghost);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  auto & mesh = this->model.getMesh();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->createGridSynchronizer();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->insertAllQuads(_ghost);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->updatePairList();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->cleanupExtraGhostElements(nb_ghost_protected);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->is_creating_grid = true;
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->grid_synchronizer = std::make_unique<GridSynchronizer>(
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:      this->model.getMesh(), *spatial_grid, *this, tags, sstr.str(), false);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->is_creating_grid = false;
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  Mesh & mesh = this->model.getMesh();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:        this->model.getFEEngine().getNbIntegrationPoints(type, ghost_type);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    const Array<Real> & quads = this->quad_coordinates(type, ghost_type);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->is_highest.zero();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->criterion.zero();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->model.updateDataForNonLocalCriterion(criterion);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->asynchronousSynchronize(SynchronizationTag::_nh_criterion);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->waitEndSynchronize(SynchronizationTag::_nh_criterion);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  Mesh & mesh = this->model.getMesh();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:        this->model.getFEEngine().getNbIntegrationPoints(type, _not_ghost);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    const Array<Real> & criterion_1 = this->criterion(lq1.type, lq1.ghost_type);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:    const Array<Real> & criterion_2 = this->criterion(lq2.type, lq2.ghost_type);
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  auto & mesh = this->model.getMesh();
common/non_local_toolbox/neighborhoods_criterion_evaluation/neighborhood_max_criterion.cc:  this->onElementsRemoved(ghosts_to_erase, remove_elem.getNewNumbering(),
common/non_linear_solver/non_linear_solver_lumped.cc:  this->supported_type.insert(NonLinearSolverType::_lumped);
common/non_linear_solver/non_linear_solver_lumped.cc:  this->checkIfTypeIsSupported();
common/non_linear_solver/non_linear_solver_lumped.cc:  this->registerParam("b_a2x", this->alpha, 1., _pat_parsmod,
common/non_linear_solver/non_linear_solver_lumped.cc:  this->dof_manager.updateGlobalBlockedDofs();
common/non_linear_solver/non_linear_solver_lumped.cc:  auto & x = aka::as_type<SolverVectorDefault>(this->dof_manager.getSolution());
common/non_linear_solver/non_linear_solver_lumped.cc:  const auto & b = this->dof_manager.getResidual();
common/non_linear_solver/non_linear_solver_lumped.cc:  const auto & blocked_dofs = this->dof_manager.getBlockedDOFs();
common/non_linear_solver/non_linear_solver_lumped.cc:  const auto & A = this->dof_manager.getLumpedMatrix("M");
common/non_linear_solver/non_linear_solver_lumped.cc:  this->dof_manager.splitSolutionPerDOFs();
common/non_linear_solver/non_linear_solver_linear.cc:  this->supported_type.insert(NonLinearSolverType::_linear);
common/non_linear_solver/non_linear_solver_linear.cc:  this->checkIfTypeIsSupported();
common/non_linear_solver/non_linear_solver_linear.cc:  this->dof_manager.updateGlobalBlockedDofs();
common/non_linear_solver/non_linear_solver_linear.cc:  this->assembleResidual(solver_callback);
common/non_linear_solver/non_linear_solver_linear.cc:  this->solver->solve();
common/non_linear_solver/non_linear_solver_linear.cc:    this->assembleResidual(solver_callback);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->supported_type.insert(NonLinearSolverType::_newton_raphson_modified);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->supported_type.insert(NonLinearSolverType::_newton_raphson_contact);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->supported_type.insert(NonLinearSolverType::_newton_raphson);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->supported_type.insert(NonLinearSolverType::_linear);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->checkIfTypeIsSupported();
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->registerParam("threshold", convergence_criteria, 1e-10, _pat_parsmod,
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->registerParam("convergence_type", convergence_criteria_type,
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->registerParam("max_iterations", max_iterations, 10, _pat_parsmod,
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->registerParam("error", error, _pat_readable, "Last reached error");
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->registerParam("nb_iterations", n_iter, _pat_readable,
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->registerParam("converged", converged, _pat_readable,
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->registerParam("force_linear_recompute", force_linear_recompute, true,
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->dof_manager.updateGlobalBlockedDofs();
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->assembleResidual(solver_callback);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  if (this->non_linear_solver_type ==
common/non_linear_solver/non_linear_solver_newton_raphson.cc:      (this->non_linear_solver_type == NonLinearSolverType::_linear &&
common/non_linear_solver/non_linear_solver_newton_raphson.cc:       this->force_linear_recompute)) {
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    this->force_linear_recompute = false;
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->n_iter = 0;
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->converged = false;
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->convergence_criteria_normalized = this->convergence_criteria;
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  if (this->convergence_criteria_type == SolveConvergenceCriteria::_residual) {
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    this->converged = this->testConvergence(this->dof_manager.getResidual());
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    if (this->converged) {
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    this->convergence_criteria_normalized =
common/non_linear_solver/non_linear_solver_newton_raphson.cc:        this->error * this->convergence_criteria;
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    if (this->non_linear_solver_type == NonLinearSolverType::_newton_raphson or
common/non_linear_solver/non_linear_solver_newton_raphson.cc:        this->non_linear_solver_type ==
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    this->solver->solve();
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    if (this->convergence_criteria_type ==
common/non_linear_solver/non_linear_solver_newton_raphson.cc:      this->assembleResidual(solver_callback);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:      this->converged = this->testConvergence(this->dof_manager.getResidual());
common/non_linear_solver/non_linear_solver_newton_raphson.cc:      this->converged = this->testConvergence(this->dof_manager.getSolution());
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    if (this->convergence_criteria_type ==
common/non_linear_solver/non_linear_solver_newton_raphson.cc:        not this->converged) {
common/non_linear_solver/non_linear_solver_newton_raphson.cc:      this->assembleResidual(solver_callback);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    this->n_iter++;
common/non_linear_solver/non_linear_solver_newton_raphson.cc:        "[" << this->convergence_criteria_type << "] Convergence iteration "
common/non_linear_solver/non_linear_solver_newton_raphson.cc:            << std::setw(std::log10(this->max_iterations)) << this->n_iter
common/non_linear_solver/non_linear_solver_newton_raphson.cc:            << ": error " << this->error << (this->converged ? " < " : " > ")
common/non_linear_solver/non_linear_solver_newton_raphson.cc:            << this->convergence_criteria_normalized);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  } while (not this->converged and this->n_iter <= this->max_iterations);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  if (this->convergence_criteria_type == SolveConvergenceCriteria::_solution) {
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    this->assembleResidual(solver_callback);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->converged =
common/non_linear_solver/non_linear_solver_newton_raphson.cc:      this->converged and not(this->n_iter > this->max_iterations);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  solver_callback.afterSolveStep(this->converged);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  if (not this->converged) {
common/non_linear_solver/non_linear_solver_newton_raphson.cc:        this->convergence_criteria, this->n_iter, this->error));
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    AKANTU_DEBUG_WARNING("[" << this->convergence_criteria_type
common/non_linear_solver/non_linear_solver_newton_raphson.cc:                             << std::setw(std::log10(this->max_iterations))
common/non_linear_solver/non_linear_solver_newton_raphson.cc:                             << this->n_iter << " iteration"
common/non_linear_solver/non_linear_solver_newton_raphson.cc:                             << (this->n_iter == 1 ? "" : "s") << "!");
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  const auto & blocked_dofs = this->dof_manager.getBlockedDOFs();
common/non_linear_solver/non_linear_solver_newton_raphson.cc:    bool is_local_node = this->dof_manager.isLocalOrMasterDOF(n);
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  this->error = norm;
common/non_linear_solver/non_linear_solver_newton_raphson.cc:  return (error < this->convergence_criteria_normalized);
common/boundary_condition/boundary_condition_functor_inline_impl.hh:      flags(this->axis) = true;
common/boundary_condition/boundary_condition_functor_inline_impl.hh:      flags(this->axis) = true;
common/boundary_condition/boundary_condition_functor_inline_impl.hh:      primal(this->axis) = value;
common/boundary_condition/boundary_condition_functor_inline_impl.hh:      flags(this->axis) = true;
common/boundary_condition/boundary_condition_functor_inline_impl.hh:      primal(this->axis) += value;
common/boundary_condition/boundary_condition_functor_inline_impl.hh:      dual = this->bc_data * normals;
common/boundary_condition/boundary_condition_functor_inline_impl.hh:      dual = this->bc_data;
common/boundary_condition/boundary_condition_functor.hh:      inline void setIncrement(Real val) { this->value = val; }
common/boundary_condition/boundary_condition_functor.hh:      inline void setIncrement(const Vector<Real> & val) { this->value = val; }
common/boundary_condition/boundary_condition_tmpl.hh:  this->model = &model;
common/boundary_condition/boundary_condition_tmpl.hh:  this->primal = &primal;
common/boundary_condition/boundary_condition_tmpl.hh:  this->dual = &dual;
common/boundary_condition/boundary_condition_tmpl.hh:  this->initBC(model, primal, dual);
common/boundary_condition/boundary_condition_tmpl.hh:  this->primal_increment = &primal_increment;
common/dof_manager/dof_manager.hh:    return this->global_blocked_dofs_release !=
common/dof_manager/dof_manager.hh:           this->previous_global_blocked_dofs_release;
common/dof_manager/dof_manager.hh:  AKANTU_GET_MACRO_AUTO(SystemSize, this->system_size);
common/dof_manager/dof_manager.hh:  AKANTU_GET_MACRO_AUTO(LocalSystemSize, this->local_system_size);
common/dof_manager/dof_manager.hh:  AKANTU_GET_MACRO_AUTO(PureLocalSystemSize, this->pure_local_system_size);
common/dof_manager/dof_manager.hh:    ID non_linear_solver_id = this->id + ":nls:" + id;
common/dof_manager/dof_manager.hh:    return this->registerNonLinearSolver(non_linear_solver_id, nls);
common/dof_manager/dof_manager.hh:    ID time_step_solver_id = this->id + ":tss:" + id;
common/dof_manager/dof_manager.hh:    return this->registerTimeStepSolver(time_step_solver_id, tss);
common/dof_manager/dof_manager.hh:    ID matrix_id = this->id + ":mtx:" + id;
common/dof_manager/dof_manager.hh:    return this->registerSparseMatrix(matrix_id, sm);
common/dof_manager/dof_manager.hh:    ID matrix_id = this->id + ":mtx:" + id;
common/dof_manager/dof_manager.hh:        aka::as_type<MatType>(this->getMatrix(matrix_to_copy_id));
common/dof_manager/dof_manager.hh:    return this->registerSparseMatrix(matrix_id, sm);
common/dof_manager/dof_manager.hh:    ID matrix_id = this->id + ":lumped_mtx:" + id;
common/dof_manager/dof_manager.hh:    return this->registerLumpedMatrix(matrix_id, sm);
common/dof_manager/dof_manager_inline_impl.hh:  auto it = this->dofs.find(dof_id);
common/dof_manager/dof_manager_inline_impl.hh:  return it != this->dofs.end();
common/dof_manager/dof_manager_inline_impl.hh:  auto it = this->dofs.find(dof_id);
common/dof_manager/dof_manager_inline_impl.hh:  if (it == this->dofs.end()) {
common/dof_manager/dof_manager_inline_impl.hh:                                << this->id);
common/dof_manager/dof_manager_inline_impl.hh:  auto it = this->dofs.find(dof_id);
common/dof_manager/dof_manager_inline_impl.hh:  if (it == this->dofs.end()) {
common/dof_manager/dof_manager_inline_impl.hh:                                << this->id);
common/dof_manager/dof_manager_inline_impl.hh:  return aka::as_type<DOFData_>(this->getDOFData(dof_id));
common/dof_manager/dof_manager_inline_impl.hh:  return aka::as_type<DOFData_>(this->getDOFData(dof_id));
common/dof_manager/dof_manager_inline_impl.hh:  return *(this->getDOFData(dofs_id).dof);
common/dof_manager/dof_manager_inline_impl.hh:  return this->getDOFData(dofs_id).support_type;
common/dof_manager/dof_manager_inline_impl.hh:  return *(this->getDOFData(dofs_id).previous);
common/dof_manager/dof_manager_inline_impl.hh:  return (this->getDOFData(dofs_id).previous != nullptr);
common/dof_manager/dof_manager_inline_impl.hh:  return *(this->getDOFData(dofs_id).increment);
common/dof_manager/dof_manager_inline_impl.hh:  return (this->getDOFData(dofs_id).increment != nullptr);
common/dof_manager/dof_manager_inline_impl.hh:  auto & derivatives = this->getDOFData(dofs_id).dof_derivatives;
common/dof_manager/dof_manager_inline_impl.hh:                                                << this->id << " for dof "
common/dof_manager/dof_manager_inline_impl.hh:  const auto & derivatives = this->getDOFData(dofs_id).dof_derivatives;
common/dof_manager/dof_manager_inline_impl.hh:  return this->getDOFData(dofs_id).solution;
common/dof_manager/dof_manager_inline_impl.hh:  return this->getDOFData(dofs_id).solution;
common/dof_manager/dof_manager_inline_impl.hh:  return *(this->getDOFData(dofs_id).blocked_dofs);
common/dof_manager/dof_manager_inline_impl.hh:  return (this->getDOFData(dofs_id).blocked_dofs != nullptr);
common/dof_manager/dof_manager_inline_impl.hh:  auto dof_flag = this->dofs_flag(dof_num);
common/dof_manager/dof_manager_inline_impl.hh:  auto dof_flag = this->dofs_flag(dof_num);
common/dof_manager/dof_manager_inline_impl.hh:  auto dof_flag = this->dofs_flag(dof_num);
common/dof_manager/dof_manager_inline_impl.hh:  return this->global_equation_number(local);
common/dof_manager/dof_manager_inline_impl.hh:  auto it = this->global_to_local_mapping.find(global);
common/dof_manager/dof_manager_inline_impl.hh:  return (it != this->global_to_local_mapping.end());
common/dof_manager/dof_manager_inline_impl.hh:  auto it = this->global_to_local_mapping.find(global);
common/dof_manager/dof_manager_inline_impl.hh:  AKANTU_DEBUG_ASSERT(it != this->global_to_local_mapping.end(),
common/dof_manager/dof_manager_inline_impl.hh:                          << global << " does not exists in " << this->id);
common/dof_manager/dof_manager_inline_impl.hh:  return this->dofs_flag(local_id);
common/dof_manager/dof_manager_inline_impl.hh:  const auto & dof_data = this->getDOFData(dof_id);
common/dof_manager/dof_manager_inline_impl.hh:  Vec tmp_array(aka::as_type<Vec>(*data_cache), this->id + ":tmp_array");
common/dof_manager/dof_manager_inline_impl.hh:  auto & dof_data = this->getDOFData(dof_id);
common/dof_manager/dof_manager_inline_impl.hh:  const auto & equation_number = this->getLocalEquationsNumbers(dof_id);
common/dof_manager/dof_manager_inline_impl.hh:          this->mesh->getElementGroup(dof_data.group_support)
common/dof_manager/dof_manager_inline_impl.hh:      nb_element = this->mesh->getNbElement(type, ghost_type);
common/dof_manager/dof_manager_inline_impl.hh:  const auto & connectivity = this->mesh->getConnectivity(type, ghost_type);
common/dof_manager/dof_manager_inline_impl.hh:    this->extractElementEquationNumber(equation_number, *conn_it,
common/dof_manager/dof_manager_inline_impl.hh:                     return this->localToGlobalEquationNumber(local);
common/dof_manager/dof_manager_inline_impl.hh:  const auto & equation_number_m = this->getLocalEquationsNumbers(dof_id_m);
common/dof_manager/dof_manager_inline_impl.hh:  const auto & equation_number_n = this->getLocalEquationsNumbers(dof_id_n);
common/dof_manager/dof_manager_inline_impl.hh:    auto gi = this->localToGlobalEquationNumber(equation_number_m(term.i()));
common/dof_manager/dof_manager_inline_impl.hh:    auto gj = this->localToGlobalEquationNumber(equation_number_n(term.j()));
common/dof_manager/dof_manager_default.cc:  if (this->mesh->isDistributed()) {
common/dof_manager/dof_manager_default.cc:    this->synchronizer = std::make_unique<DOFSynchronizer>(
common/dof_manager/dof_manager_default.cc:        *this, this->id + ":dof_synchronizer");
common/dof_manager/dof_manager_default.cc:  auto & dof_data = this->getDOFDataTyped<DOFDataDefault>(dof_id);
common/dof_manager/dof_manager_default.cc:  this->mesh->getPeriodicNodeSynchronizer()
common/dof_manager/dof_manager_default.cc:  auto & dof_data = this->getDOFDataTyped<DOFDataDefault>(dof_id);
common/dof_manager/dof_manager_default.cc:      // scale_factor * (arr) * (not this->mesh->isPeriodicSlave(node));
common/dof_manager/dof_manager_default.cc:  if (this->synchronizer) {
common/dof_manager/dof_manager_default.cc:    this->synchronizer->registerDOFs(dof_id);
common/dof_manager/dof_manager_default.cc:  return this->registerSparseMatrix<SparseMatrixAIJ>(*this, id, matrix_type);
common/dof_manager/dof_manager_default.cc:  return this->registerSparseMatrix<SparseMatrixAIJ>(id, matrix_to_copy_id);
common/dof_manager/dof_manager_default.cc:  return this->registerLumpedMatrix<SolverVectorDefault>(*this, id);
common/dof_manager/dof_manager_default.cc:    return this->registerNonLinearSolver<NonLinearSolverNewtonRaphson>(
common/dof_manager/dof_manager_default.cc:    return this->registerNonLinearSolver<NonLinearSolverLinear>(*this, id,
common/dof_manager/dof_manager_default.cc:    return this->registerNonLinearSolver<NonLinearSolverLumped>(*this, id,
common/dof_manager/dof_manager_default.cc:  return this->registerTimeStepSolver<TimeStepSolverDefault>(
common/dof_manager/dof_manager_default.cc:  const auto & equation_number = this->getLocalEquationsNumbers(dof_id);
common/dof_manager/dof_manager_default.cc:      aka::as_type<SolverVectorArray>(this->getLumpedMatrix(A_id)).getVector();
common/dof_manager/dof_manager_default.cc:  auto & cache = aka::as_type<SolverVectorArray>(*this->data_cache);
common/dof_manager/dof_manager_default.cc:  this->assembleToGlobalArray(dof_id, x, cache.getVector(), scale_factor);
common/dof_manager/dof_manager_default.cc:                          make_view(this->getResidualArray()))) {
common/dof_manager/dof_manager_default.cc:  this->addToProfile(matrix_id, dof_id, type, ghost_type);
common/dof_manager/dof_manager_default.cc:  const auto & dof_data = this->getDOFData(dof_id);
common/dof_manager/dof_manager_default.cc:  auto prof_it = this->matrix_profiled_dofs.find(mat_dof);
common/dof_manager/dof_manager_default.cc:  if (prof_it != this->matrix_profiled_dofs.end() &&
common/dof_manager/dof_manager_default.cc:  const auto & equation_number = this->getLocalEquationsNumbers(dof_id);
common/dof_manager/dof_manager_default.cc:  auto & A = this->getMatrix(matrix_id);
common/dof_manager/dof_manager_default.cc:  const auto & connectivity = this->mesh->getConnectivity(type, ghost_type);
common/dof_manager/dof_manager_default.cc:        this->mesh->getElementGroup(dof_data.group_support)
common/dof_manager/dof_manager_default.cc:    this->extractElementEquationNumber(
common/dof_manager/dof_manager_default.cc:        [&](auto & local) { return this->localToGlobalEquationNumber(local); });
common/dof_manager/dof_manager_default.cc:  this->matrix_profiled_dofs[mat_dof].push_back(type_pair);
common/dof_manager/dof_manager_default.cc:  return dynamic_cast<SolverVectorDefault *>(this->solution.get())->getVector();
common/dof_manager/dof_manager_default.cc:  return dynamic_cast<SolverVectorDefault *>(this->residual.get())->getVector();
common/dof_manager/dof_manager_default.cc:  return dynamic_cast<SolverVectorDefault *>(this->residual.get())->getVector();
common/dof_manager/dof_manager_default.cc:  if (this->synchronizer) {
common/dof_manager/dof_manager_default.cc:    this->synchronizer->onNodesAdded(nodes_list);
common/dof_manager/dof_manager_default.cc:  this->global_blocked_dofs.resize(this->local_system_size, 1);
common/dof_manager/dof_manager_default.cc:  this->previous_global_blocked_dofs.resize(this->local_system_size, 1);
common/dof_manager/dof_manager_default.cc:  if (this->global_blocked_dofs_release ==
common/dof_manager/dof_manager_default.cc:      this->previous_global_blocked_dofs_release) {
common/dof_manager/dof_manager.cc:  this->mesh->registerEventHandler(*this, _ehp_dof_manager);
common/dof_manager/dof_manager.cc:  for (const auto & dof_data : this->dofs) {
common/dof_manager/dof_manager.cc:    nb_element = this->mesh->getNbElement(type, ghost_type);
common/dof_manager/dof_manager.cc:  const auto & connectivity = this->mesh->getConnectivity(type, ghost_type);
common/dof_manager/dof_manager.cc:  Array<Real> array_localy_assembeled(this->mesh->getNbNodes(),
common/dof_manager/dof_manager.cc:  this->assembleElementalArrayLocalArray(
common/dof_manager/dof_manager.cc:  this->assembleToResidual(dof_id, array_localy_assembeled, 1);
common/dof_manager/dof_manager.cc:  Array<Real> array_localy_assembeled(this->mesh->getNbNodes(),
common/dof_manager/dof_manager.cc:  this->assembleElementalArrayLocalArray(
common/dof_manager/dof_manager.cc:  this->assembleToLumpedMatrix(dof_id, array_localy_assembeled, lumped_mtx, 1);
common/dof_manager/dof_manager.cc:  for (auto & pair : this->dofs) {
common/dof_manager/dof_manager.cc:    this->assembleMatMulVectToResidual(dof_id, A_id, *dof_data.dof,
common/dof_manager/dof_manager.cc:  for (auto && data : this->dofs) {
common/dof_manager/dof_manager.cc:    this->getSolutionPerDOFs(data.first, dof_data.solution);
common/dof_manager/dof_manager.cc:  this->getArrayPerDOFs(dof_id, this->getSolution(), solution_array);
common/dof_manager/dof_manager.cc:  this->getArrayPerDOFs(dof_id, this->getLumpedMatrix(lumped_mtx), lumped);
common/dof_manager/dof_manager.cc:  // this->makeConsistentForPeriodicity(dof_id, array_to_assemble);
common/dof_manager/dof_manager.cc:  this->assembleToGlobalArray(dof_id, array_to_assemble, this->getResidual(),
common/dof_manager/dof_manager.cc:  // this->makeConsistentForPeriodicity(dof_id, array_to_assemble);
common/dof_manager/dof_manager.cc:  auto & lumped = this->getLumpedMatrix(lumped_mtx);
common/dof_manager/dof_manager.cc:  this->assembleToGlobalArray(dof_id, array_to_assemble, lumped, scale_factor);
common/dof_manager/dof_manager.cc:    nb_pure_local += this->mesh->isLocalOrMasterNode(node);
common/dof_manager/dof_manager.cc:    nb_local_dofs -= this->mesh->isPeriodicSlave(node);
common/dof_manager/dof_manager.cc:  auto it = this->dofs.find(dof_id);
common/dof_manager/dof_manager.cc:  if (it != this->dofs.end()) {
common/dof_manager/dof_manager.cc:  std::unique_ptr<DOFData> dof_data_ptr = this->getNewDOFData(dof_id);
common/dof_manager/dof_manager.cc:  this->dofs[dof_id] = std::move(dof_data_ptr);
common/dof_manager/dof_manager.cc:  auto & dofs_storage = this->getNewDOFDataInternal(dof_id);
common/dof_manager/dof_manager.cc:  this->registerDOFsInternal(dof_id, dofs_array);
common/dof_manager/dof_manager.cc:  auto & dofs_storage = this->getNewDOFDataInternal(dof_id);
common/dof_manager/dof_manager.cc:  this->registerDOFsInternal(dof_id, dofs_array);
common/dof_manager/dof_manager.cc:  DOFData & dof_data = this->getDOFData(dof_id);
common/dof_manager/dof_manager.cc:          dofs_array.size() == this->mesh->getNbNodes(),
common/dof_manager/dof_manager.cc:          dof_data, this->mesh->getNbNodes(), [](auto && n) { return n; });
common/dof_manager/dof_manager.cc:          this->mesh->getElementGroup(group).getNodeGroup().getNodes();
common/dof_manager/dof_manager.cc:  this->pure_local_system_size += nb_pure_local;
common/dof_manager/dof_manager.cc:  this->local_system_size += nb_local_dofs;
common/dof_manager/dof_manager.cc:  this->system_size += nb_total_pure_local;
common/dof_manager/dof_manager.cc:          this->mesh->getElementGroup(group).getNodeGroup().getNodes();
common/dof_manager/dof_manager.cc:      this->updateDOFsData(
common/dof_manager/dof_manager.cc:      this->updateDOFsData(dof_data, nb_local_dofs, nb_pure_local,
common/dof_manager/dof_manager.cc:    this->updateDOFsData(dof_data, nb_local_dofs, nb_pure_local);
common/dof_manager/dof_manager.cc:  DOFData & dof = this->getDOFData(dof_id);
common/dof_manager/dof_manager.cc:  DOFData & dof = this->getDOFData(dof_id);
common/dof_manager/dof_manager.cc:  auto & dof = this->getDOFData(dof_id);
common/dof_manager/dof_manager.cc:  auto & dof = this->getDOFData(dof_id);
common/dof_manager/dof_manager.cc:  auto it = this->matrices.find(matrix_id);
common/dof_manager/dof_manager.cc:  if (it != this->matrices.end()) {
common/dof_manager/dof_manager.cc:                                   << this->id);
common/dof_manager/dof_manager.cc:  this->matrices[matrix_id] = std::move(matrix);
common/dof_manager/dof_manager.cc:  auto it = this->lumped_matrices.find(matrix_id);
common/dof_manager/dof_manager.cc:  if (it != this->lumped_matrices.end()) {
common/dof_manager/dof_manager.cc:                                          << this->id);
common/dof_manager/dof_manager.cc:  this->lumped_matrices[matrix_id] = std::move(matrix);
common/dof_manager/dof_manager.cc:      this->non_linear_solvers.find(non_linear_solver_id);
common/dof_manager/dof_manager.cc:  if (it != this->non_linear_solvers.end()) {
common/dof_manager/dof_manager.cc:                                              << this->id);
common/dof_manager/dof_manager.cc:  this->non_linear_solvers[non_linear_solver_id] = std::move(non_linear_solver);
common/dof_manager/dof_manager.cc:      this->time_step_solvers.find(time_step_solver_id);
common/dof_manager/dof_manager.cc:  if (it != this->time_step_solvers.end()) {
common/dof_manager/dof_manager.cc:                                              << this->id);
common/dof_manager/dof_manager.cc:  this->time_step_solvers[time_step_solver_id] = std::move(time_step_solver);
common/dof_manager/dof_manager.cc:  ID matrix_id = this->id + ":mtx:" + id;
common/dof_manager/dof_manager.cc:  SparseMatricesMap::const_iterator it = this->matrices.find(matrix_id);
common/dof_manager/dof_manager.cc:  if (it == this->matrices.end()) {
common/dof_manager/dof_manager.cc:                                          << this->id);
common/dof_manager/dof_manager.cc:  ID mtx_id = this->id + ":mtx:" + id;
common/dof_manager/dof_manager.cc:  auto it = this->matrices.find(mtx_id);
common/dof_manager/dof_manager.cc:  return it != this->matrices.end();
common/dof_manager/dof_manager.cc:  ID matrix_id = this->id + ":lumped_mtx:" + id;
common/dof_manager/dof_manager.cc:  LumpedMatricesMap::const_iterator it = this->lumped_matrices.find(matrix_id);
common/dof_manager/dof_manager.cc:  if (it == this->lumped_matrices.end()) {
common/dof_manager/dof_manager.cc:                            << matrix_id << " does not exists in " << this->id);
common/dof_manager/dof_manager.cc:  ID matrix_id = this->id + ":lumped_mtx:" + id;
common/dof_manager/dof_manager.cc:  auto it = this->lumped_matrices.find(matrix_id);
common/dof_manager/dof_manager.cc:  if (it == this->lumped_matrices.end()) {
common/dof_manager/dof_manager.cc:                            << matrix_id << " does not exists in " << this->id);
common/dof_manager/dof_manager.cc:  ID mtx_id = this->id + ":lumped_mtx:" + id;
common/dof_manager/dof_manager.cc:  auto it = this->lumped_matrices.find(mtx_id);
common/dof_manager/dof_manager.cc:  return it != this->lumped_matrices.end();
common/dof_manager/dof_manager.cc:  ID non_linear_solver_id = this->id + ":nls:" + id;
common/dof_manager/dof_manager.cc:      this->non_linear_solvers.find(non_linear_solver_id);
common/dof_manager/dof_manager.cc:  if (it == this->non_linear_solvers.end()) {
common/dof_manager/dof_manager.cc:                                              << this->id);
common/dof_manager/dof_manager.cc:  ID solver_id = this->id + ":nls:" + id;
common/dof_manager/dof_manager.cc:  auto it = this->non_linear_solvers.find(solver_id);
common/dof_manager/dof_manager.cc:  return it != this->non_linear_solvers.end();
common/dof_manager/dof_manager.cc:  ID time_step_solver_id = this->id + ":tss:" + id;
common/dof_manager/dof_manager.cc:      this->time_step_solvers.find(time_step_solver_id);
common/dof_manager/dof_manager.cc:  if (it == this->time_step_solvers.end()) {
common/dof_manager/dof_manager.cc:                                              << this->id);
common/dof_manager/dof_manager.cc:  ID time_step_solver_id = this->id + ":tss:" + solver_id;
common/dof_manager/dof_manager.cc:  auto it = this->time_step_solvers.find(time_step_solver_id);
common/dof_manager/dof_manager.cc:  return it != this->time_step_solvers.end();
common/dof_manager/dof_manager.cc:  this->getPreviousDOFs(dofs_id).copy(this->getDOFs(dofs_id));
common/dof_manager/dof_manager.cc:void DOFManager::zeroResidual() { this->residual->zero(); }
common/dof_manager/dof_manager.cc:void DOFManager::zeroMatrix(const ID & mtx) { this->getMatrix(mtx).zero(); }
common/dof_manager/dof_manager.cc:  this->getLumpedMatrix(mtx).zero();
common/dof_manager/dof_manager.cc:  auto & dof_data = this->getDOFData(dof_id);
common/dof_manager/dof_manager.cc:  this->pure_local_system_size += nb_new_pure_local;
common/dof_manager/dof_manager.cc:  this->local_system_size += nb_new_local_dofs;
common/dof_manager/dof_manager.cc:  this->system_size += nb_new_global;
common/dof_manager/dof_manager.cc:  this->residual->resize();
common/dof_manager/dof_manager.cc:  this->solution->resize();
common/dof_manager/dof_manager.cc:  this->data_cache->resize();
common/dof_manager/dof_manager.cc:  for (auto & pair : this->dofs) {
common/dof_manager/dof_manager.cc:    auto & dof_data = this->getDOFData(dof_id);
common/dof_manager/dof_manager.cc:      this->updateNodalDOFs(dof_id, nodes_list);
common/dof_manager/dof_manager.cc:          this->mesh->getElementGroup(group).getNodeGroup();
common/dof_manager/dof_manager.cc:      this->updateNodalDOFs(dof_id, new_nodes_list);
common/dof_manager/dof_manager.cc:  this->resizeGlobalArrays();
common/dof_manager/dof_manager.cc:  AKANTU_DEBUG_ASSERT(this->mesh != nullptr, "The `Mesh` pointer is not set.");
common/dof_manager/dof_manager.cc:  if (this->mesh->isDistributed() != this->residual->isDistributed()) {
common/dof_manager/dof_manager.cc:                     << is_or_is_not(this->mesh->isDistributed())
common/dof_manager/dof_manager.cc:                     << is_or_is_not(this->residual->isDistributed())
common/dof_manager/dof_manager.cc:                     << debug::demangle(typeid(this->residual).name()) << ".");
common/dof_manager/dof_manager.cc:  this->communicator.exclusiveScan(nb_new_pure_local, offset);
common/dof_manager/dof_manager.cc:  auto first_global_dof_id = this->first_global_dof_id + offset;
common/dof_manager/dof_manager.cc:  auto first_local_dof_id = this->local_system_size - nb_new_local_dofs;
common/dof_manager/dof_manager.cc:  this->communicator.allReduce(offset);
common/dof_manager/dof_manager.cc:  this->first_global_dof_id += offset;
common/dof_manager/dof_manager.cc:  this->dofs_flag.resize(this->local_system_size, NodeFlag::_normal);
common/dof_manager/dof_manager.cc:  this->global_equation_number.resize(this->local_system_size, -1);
common/dof_manager/dof_manager.cc:    auto dof_flag = this->mesh->getNodeFlag(node);
common/dof_manager/dof_manager.cc:    auto is_local_dof = this->mesh->isLocalOrMasterNode(node);
common/dof_manager/dof_manager.cc:    auto is_periodic_slave = this->mesh->isPeriodicSlave(node);
common/dof_manager/dof_manager.cc:    auto is_periodic_master = this->mesh->isPeriodicMaster(node);
common/dof_manager/dof_manager.cc:    this->dofs_flag(local_eq_num) = dof_flag;
common/dof_manager/dof_manager.cc:      this->global_equation_number(local_eq_num) = first_global_dof_id;
common/dof_manager/dof_manager.cc:      this->global_to_local_mapping[first_global_dof_id] = local_eq_num;
common/dof_manager/dof_manager.cc:      this->global_equation_number(local_eq_num) = -1;
common/dof_manager/dof_manager.cc:  if (this->mesh->isPeriodic()) {
common/dof_manager/dof_manager.cc:      if (not this->mesh->isPeriodicSlave(node)) {
common/dof_manager/dof_manager.cc:      auto master_node = this->mesh->getPeriodicMaster(node);
common/dof_manager/dof_manager.cc:  if (this->mesh->isDistributed()) {
common/dof_manager/dof_manager.cc:    if (this->mesh->isPeriodic()) {
common/dof_manager/dof_manager.cc:    auto & node_synchronizer = this->mesh->getNodeSynchronizer();
common/dof_manager/dof_manager.cc:  this->dofs_flag.resize(this->local_system_size, NodeFlag::_normal);
common/dof_manager/dof_manager.cc:  this->global_equation_number.resize(this->local_system_size, -1);
common/dof_manager/dof_manager.cc:    this->dofs_flag(first_local_dof_id) = NodeFlag::_normal;
common/dof_manager/dof_manager.cc:    this->global_equation_number(first_local_dof_id) = first_global_dof_id;
common/dof_manager/dof_manager.cc:    this->global_to_local_mapping[first_global_dof_id] = first_local_dof_id;
common/dof_manager/dof_manager.cc:  this->previous_global_blocked_dofs.copy(this->global_blocked_dofs);
common/dof_manager/dof_manager.cc:  this->global_blocked_dofs.reserve(this->local_system_size, 0);
common/dof_manager/dof_manager.cc:  this->previous_global_blocked_dofs_release =
common/dof_manager/dof_manager.cc:      this->global_blocked_dofs_release;
common/dof_manager/dof_manager.cc:    if (not this->hasBlockedDOFs(pair.first)) {
common/dof_manager/dof_manager.cc:        this->global_blocked_dofs.push_back(dof);
common/dof_manager/dof_manager.cc:  std::sort(this->global_blocked_dofs.begin(), this->global_blocked_dofs.end());
common/dof_manager/dof_manager.cc:  auto last = std::unique(this->global_blocked_dofs.begin(),
common/dof_manager/dof_manager.cc:                          this->global_blocked_dofs.end());
common/dof_manager/dof_manager.cc:  this->global_blocked_dofs.resize(last - this->global_blocked_dofs.begin());
common/dof_manager/dof_manager.cc:    ++this->global_blocked_dofs_release;
common/dof_manager/dof_manager.cc:  auto & J = this->getMatrix(matrix_id);
common/dof_manager/dof_manager.cc:  if (this->jacobian_release == J.getRelease()) {
common/dof_manager/dof_manager.cc:    if (this->hasBlockedDOFsChanged()) {
common/dof_manager/dof_manager.cc:  this->jacobian_release = J.getRelease();
common/dof_manager/dof_manager.cc:  this->previous_global_blocked_dofs_release =
common/dof_manager/dof_manager.cc:      this->global_blocked_dofs_release;
common/dof_manager/dof_manager.cc:  auto & A = this->getMatrix(A_id);
common/dof_manager/dof_manager.cc:  this->assembleToGlobalArray(dof_id, x, *data_cache, 1.);
common/model_solver.hh:  DOFManager & getDOFManager() { return *this->dof_manager; }
common/constitutive_laws/constitutive_law_selector.hh:    this->fallback_selector = fallback_selector;
common/constitutive_laws/constitutive_law_selector.hh:    this->fallback_selector = fallback_selector.shared_from_this();
common/constitutive_laws/constitutive_law_selector.hh:    return this->fallback_selector;
common/constitutive_laws/constitutive_law_selector.hh:  inline Idx getFallbackValue() const { return this->fallback_value; }
common/constitutive_laws/constitutive_law_selector_tmpl.hh:    auto && data = this->elementData(element);
common/constitutive_laws/constitutive_law_selector_tmpl.hh:      return this->model.getConstitutiveLawIndex(data);
common/constitutive_laws/constitutive_law_tmpl.hh:  return this->registerInternal<T, InternalFieldType>(
common/constitutive_laws/constitutive_law_tmpl.hh:      id, nb_component, this->default_fe_engine_id);
common/constitutive_laws/constitutive_law_tmpl.hh:  return this->registerInternal<T, InternalFieldType>(
common/constitutive_laws/constitutive_law_tmpl.hh:      id, nb_component, fe_engine_id, this->getElementFilter());
common/constitutive_laws/constitutive_law_tmpl.hh:          id, *this, this->spatial_dimension, fe_engine_id, element_filter));
common/constitutive_laws/constitutive_law_tmpl.hh:  if (auto it = this->internal_vectors.find(id);
common/constitutive_laws/constitutive_law_tmpl.hh:    auto && internal = this->template getInternal<T>(vect_id);
common/constitutive_laws/constitutive_law_tmpl.hh:    auto && internal = this->template getInternal<T>(vect_id);
common/constitutive_laws/constitutive_law_tmpl.hh:  this->getElementFilter().initialize(
common/constitutive_laws/constitutive_law_tmpl.hh:  this->initialize();
common/constitutive_laws/constitutive_law_tmpl.hh:  this->resizeInternals();
common/constitutive_laws/constitutive_law_tmpl.hh:  this->updateInternalParameters();
common/constitutive_laws/constitutive_law_tmpl.hh:    auto index = this->addElement(element);
common/constitutive_laws/constitutive_law_tmpl.hh:  this->resizeInternals();
common/constitutive_laws/constitutive_law_tmpl.hh:  this->removeIntegrationPoints(constitutive_law_local_new_numbering);
common/constitutive_laws/constitutive_law_tmpl.hh:  this->resizeInternals();
common/constitutive_laws/constitutive_law_tmpl.hh:      auto & law_indexes = this->handler.constitutive_law_index(type, gt);
common/constitutive_laws/constitutive_law_tmpl.hh:          this->handler.constitutive_law_local_numbering(type, gt);
common/constitutive_laws/constitutive_law_tmpl.hh:      auto nb_element = this->handler.getMesh().getNbElement(type, gt);
common/constitutive_laws/constitutive_law_tmpl.hh:  this->removeIntegrationPoints(constitutive_law_local_new_numbering);
common/constitutive_laws/constitutive_law_tmpl.hh:  auto law_index = handler.getConstitutiveLawIndex(this->name);
common/constitutive_laws/constitutive_law_tmpl.hh:                          << this->name << std::endl);
common/constitutive_laws/constitutive_law_tmpl.hh:  global_element.element = this->getElementFilter()(local_element);
common/constitutive_laws/constitutive_law_tmpl.hh:  auto & el_filter = this->getElementFilter(element.type, element.ghost_type);
common/constitutive_laws/constitutive_law_tmpl.hh:  if (not this->template isInternal<T>(field_id, element_kind)) {
common/constitutive_laws/constitutive_law_tmpl.hh:                     << id << " in the constitutive law " << this->name);
common/constitutive_laws/constitutive_law_tmpl.hh:  const auto & internal_field = this->template getInternal<T>(field_id);
common/constitutive_laws/constitutive_law_tmpl.hh:  if (!this->template isInternal<T>(field_id, element_kind)) {
common/constitutive_laws/constitutive_law_tmpl.hh:                     << id << " in the constitutive law " << this->name);
common/constitutive_laws/constitutive_law_tmpl.hh:  const auto & internal_field = this->template getInternal<T>(field_id);
common/constitutive_laws/constitutive_law_tmpl.hh:  if (not this->template isInternal<T>(field_id, element_kind)) {
common/constitutive_laws/constitutive_law_tmpl.hh:                                                   << this->name);
common/constitutive_laws/constitutive_law_tmpl.hh:  auto & internal_field = this->template getInternal<T>(field_id);
common/constitutive_laws/constitutive_law_non_local_interface.hh:    this->registerNeighborhood();
common/constitutive_laws/constitutive_law_non_local_interface.hh:    this->registerNonLocalVariables();
common/constitutive_laws/constitutive_law_non_local_interface.hh:  ID getNeighborhoodName() override { return this->name; }
common/constitutive_laws/constitutive_laws_handler.hh:    this->registerDataAccessor(*this);
common/constitutive_laws/constitutive_laws_handler.hh:    if (this->mesh.isDistributed()) {
common/constitutive_laws/constitutive_laws_handler.hh:      auto & synchronizer = this->mesh.getElementSynchronizer();
common/constitutive_laws/constitutive_laws_handler.hh:      this->registerSynchronizer(synchronizer,
common/constitutive_laws/constitutive_laws_handler.hh:    if (not this->parser.getLastParsedFile().empty()) {
common/constitutive_laws/constitutive_laws_handler.hh:      auto && [model_section, is_empty] = this->getParserSection();
common/constitutive_laws/constitutive_laws_handler.hh:      this->instantiateConstitutiveLaws(is_empty ? this->parser
common/constitutive_laws/constitutive_laws_handler.hh:      this->initConstitutiveLaws();
common/constitutive_laws/constitutive_laws_handler.hh:    return this->parser_type;
common/constitutive_laws/constitutive_laws_handler.hh:    this->constitutive_law_selector = constitutive_law_selector;
common/constitutive_laws/internal_field.hh:        this->spatial_dimension, ghost_type, this->element_kind);
common/constitutive_laws/internal_field.hh:    return this->element_filter.elementTypes(
common/constitutive_laws/internal_field.hh:        _spatial_dimension = this->spatial_dimension,
common/constitutive_laws/internal_field.hh:        _element_kind = this->element_kind, _ghost_type = ghost_type);
common/constitutive_laws/internal_field.hh:    return (this->element_filter(type, ghost_type));
common/constitutive_laws/internal_field.hh:                            << this->getID() << " has not been activated");
common/constitutive_laws/internal_field.hh:    return this->previous_values->operator()(type, ghost_type);
common/constitutive_laws/internal_field.hh:                            << this->getID() << " has not been activated");
common/constitutive_laws/internal_field.hh:    return this->previous_values->operator()(type, ghost_type);
common/constitutive_laws/internal_field.hh:                            << this->getID() << " has not been activated");
common/constitutive_laws/internal_field.hh:    return *(this->previous_values);
common/constitutive_laws/internal_field.hh:                            << this->getID() << " has not been activated");
common/constitutive_laws/internal_field.hh:    return *(this->previous_values);
common/constitutive_laws/internal_field_tmpl.hh:  this->internalInitialize(this->nb_component);
common/constitutive_laws/internal_field_tmpl.hh:  this->element_kind = element_kind;
common/constitutive_laws/internal_field_tmpl.hh:        new InternalField<T>("previous_" + this->getID(), *this));
common/constitutive_laws/internal_field_tmpl.hh:  if (not this->is_init) {
common/constitutive_laws/internal_field_tmpl.hh:    for (const auto & type : this->filterTypes(ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:      if (this->exists(type, ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:        old_sizes(type, ghost_type) = this->operator()(type, ghost_type).size();
common/constitutive_laws/internal_field_tmpl.hh:    for (const auto & type : this->elementTypes(ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:      auto & vect = this->operator()(type, ghost_type);
common/constitutive_laws/internal_field_tmpl.hh:      this->setArrayValues(vect.data() + old_size * vect.getNbComponent(),
common/constitutive_laws/internal_field_tmpl.hh:      this->releases(type, ghost_type) += 1;
common/constitutive_laws/internal_field_tmpl.hh:  if (this->previous_values) {
common/constitutive_laws/internal_field_tmpl.hh:    this->previous_values->resize();
common/constitutive_laws/internal_field_tmpl.hh:  this->default_value = value;
common/constitutive_laws/internal_field_tmpl.hh:  this->reset();
common/constitutive_laws/internal_field_tmpl.hh:    for (const auto & type : this->elementTypes(ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:      this->setArrayValues(vect.data(),
common/constitutive_laws/internal_field_tmpl.hh:      this->releases(type, ghost_type) += 1;
common/constitutive_laws/internal_field_tmpl.hh:  if (not this->is_init) {
common/constitutive_laws/internal_field_tmpl.hh:    this->nb_component = nb_component;
common/constitutive_laws/internal_field_tmpl.hh:    this->is_init = true;
common/constitutive_laws/internal_field_tmpl.hh:    for (const auto & type : this->filterTypes(ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:      this->releases(type, ghost_type) = -1;
common/constitutive_laws/internal_field_tmpl.hh:  this->reset();
common/constitutive_laws/internal_field_tmpl.hh:  if (this->previous_values) {
common/constitutive_laws/internal_field_tmpl.hh:    this->previous_values->internalInitialize(nb_component);
common/constitutive_laws/internal_field_tmpl.hh:    *begin = this->default_value;
common/constitutive_laws/internal_field_tmpl.hh:  AKANTU_DEBUG_ASSERT(this->previous_values != nullptr,
common/constitutive_laws/internal_field_tmpl.hh:                          << this->getID() << " has not been activated");
common/constitutive_laws/internal_field_tmpl.hh:  if (not this->is_init) {
common/constitutive_laws/internal_field_tmpl.hh:    for (const auto & type : this->elementTypes(ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:      (*this->previous_values)(type, ghost_type)
common/constitutive_laws/internal_field_tmpl.hh:  AKANTU_DEBUG_ASSERT(this->previous_values != nullptr,
common/constitutive_laws/internal_field_tmpl.hh:                          << this->getID() << " has not been activated");
common/constitutive_laws/internal_field_tmpl.hh:  if (not this->is_init) {
common/constitutive_laws/internal_field_tmpl.hh:    for (const auto & type : this->elementTypes(ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:          .copy((*this->previous_values)(type, ghost_type));
common/constitutive_laws/internal_field_tmpl.hh:      if (not this->exists(type, ghost_type)) {
common/constitutive_laws/internal_field_tmpl.hh:  stream << "InternalField [ " << this->getID();
common/constitutive_laws/internal_field_tmpl.hh:    stream << " {" << this->getData(_not_ghost).size() << " types - "
common/constitutive_laws/internal_field_tmpl.hh:           << this->getData(_ghost).size() << " ghost types"
common/constitutive_laws/constitutive_law.hh:    this->element_filter =
common/constitutive_laws/constitutive_law.hh:    return this->getElementFilter().elementTypes(std::forward<pack>(_pack)...);
common/constitutive_laws/random_internal_field_tmpl.hh:  this->internalInitialize(nb_component);
common/constitutive_laws/random_internal_field_tmpl.hh:  this->reset();
common/constitutive_laws/random_internal_field_tmpl.hh:  this->reset();
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:  auto & neighborhood = this->getModel().getNonLocalManager().getNeighborhood(
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:      this->getNeighborhoodName());
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:       this->getElementFilter().elementTypes(dim, ghost_type, _ek_regular)) {
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:    const auto & elem_filter = this->getElementFilter(type, ghost_type);
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:    auto nb_quad = this->getFEEngine().getNbIntegrationPoints(type, ghost_type);
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:       this->getElementFilter().elementTypes(dim, ghost_type, kind)) {
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:        this->template getInternal<Real>(field_id)(el_type, ghost_type);
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:    const auto & filter = this->getElementFilter(el_type, ghost_type);
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:        this->getFEEngine().getNbIntegrationPoints(el_type, ghost_type);
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:  ID name = this->getNeighborhoodName();
common/constitutive_laws/constitutive_law_non_local_interface_tmpl.hh:  this->handler.getNonLocalManager().registerNeighborhood(name, name);
common/constitutive_laws/random_internal_field.hh:    return aka::as_type<RandomInternalField>(this->shared_from_this());
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        "The model " << this->id << " has no constitutive_law named " << name);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:                      "The model " << this->id
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:                      "The model " << this->id
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        "The model " << this->id << " has no constitutive_law named " << name);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        "The model " << this->id << " has no constitutive_law named " << name);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->splitElementByConstitutiveLaw(elements, elements_per_cl);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  auto && cl = this->registerNewConstitutiveLaw(cl_name, cl_type, opt_param);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  sstr_cl << this->id << ":" << cl_count << ":" << cl_type;
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:      cl_type, this->spatial_dimension, opt_param,
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:      parser_section.getSubSections(this->parser_type);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:    this->registerNewConstitutiveLaw(section);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:    this->non_local_manager = std::make_unique<NonLocalManager>(
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        *this, *this, this->id + ":non_local_manager");
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        "No constitutive_laws where instantiated for the model " << this->id);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:      this->mesh,
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:      this->mesh,
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->synchronize(SynchronizationTag::_constitutive_law_id);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->assignConstitutiveLawToElements();
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->synchronize(SynchronizationTag::_clh_init_cl);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  if (this->non_local_manager) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:    this->non_local_manager->initialize();
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  for_each_element(this->mesh, [&](auto && element) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->non_local_manager->synchronize(
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        "quadrature_points_coordinates_tmp_nl", this->id);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        fe_engine, _nb_component = this->spatial_dimension,
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:             this->spatial_dimension, ghost_type)) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:    cl_el.element = this->constitutive_law_local_numbering(el);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:    auto cl_id = this->constitutive_law_index(el);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->constitutive_law_index.initialize(
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:      this->mesh, _element_kind = _ek_not_defined, _with_nb_element = true,
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->constitutive_law_local_numbering.initialize(
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:      this->mesh, _element_kind = _ek_not_defined, _with_nb_element = true,
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  ElementTypeMapArray<Idx> filter("new_element_filter", this->id);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:    if (this->mesh.getSpatialDimension(elem.type) != this->spatial_dimension) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  this->assignConstitutiveLawToElements(&filter);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  if (!(this->isInternal(field_name, element_kind))) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  auto it = this->registered_internals.find(key);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  if (it == this->registered_internals.end()) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:        std::make_unique<ElementTypeMapArray<T>>(field_name, this->id);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:    this->registered_internals[key] = std::move(internal);
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:       this->mesh.elementTypes(this->spatial_dimension, ghost_type, kind)) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:  for (auto & internal : this->registered_internals) {
common/constitutive_laws/constitutive_laws_handler_tmpl.hh:      this->flattenInternal(_id, kind);
common/model_solver.cc:        std::string name = section.getParameter("name", this->id);
common/model_solver.cc:        return type == model_type and name == this->id;
common/model_solver.cc:    this->dof_manager = dof_manager;
common/model_solver.cc:    this->setDOFManager(*this->dof_manager);
common/model_solver.cc:    return this->dof_manager;
common/model_solver.cc:  auto && [section, is_empty] = this->getParserSection();
common/model_solver.cc:    return this->initDOFManager(section, solver_type);
common/model_solver.cc:  return this->initDOFManager(solver_type);
common/model_solver.cc:    this->dof_manager = DOFManagerFactory::getInstance().allocate(
common/model_solver.cc:        solver_type, mesh, this->id + ":dof_manager_" + solver_type);
common/model_solver.cc:  this->setDOFManager(*this->dof_manager);
common/model_solver.cc:  return this->dof_manager;
common/model_solver.cc:  this->initDOFManager(solver_type);
common/model_solver.cc:    auto tss_options = this->getDefaultSolverOptions(tss_type);
common/model_solver.cc:    this->getNewSolver(solver_id, tss_type, nls_type);
common/model_solver.cc:      this->dof_manager->getNonLinearSolver(solver_id).parseSection(
common/model_solver.cc:      this->setIntegrationScheme(solver_id, dof_id, it_type, s_type);
common/model_solver.cc:      if (!this->hasIntegrationScheme(solver_id, is_type.first)) {
common/model_solver.cc:        this->setIntegrationScheme(solver_id, is_type.first, is_type.second,
common/model_solver.cc:    if (this->hasSolver(default_solver)) {
common/model_solver.cc:      this->setDefaultSolver(default_solver);
common/model_solver.cc:  return this->dof_manager;
common/model_solver.cc:    tmp_solver_id = this->default_solver_id;
common/model_solver.cc:  TimeStepSolver & tss = this->dof_manager->getTimeStepSolver(tmp_solver_id);
common/model_solver.cc:    tmp_solver_id = this->default_solver_id;
common/model_solver.cc:      this->dof_manager->getTimeStepSolver(tmp_solver_id);
common/model_solver.cc:  return this->getSolver(solver_id);
common/model_solver.cc:  return this->getSolver(solver_id);
common/model_solver.cc:  return this->getSolver(solver_id).getNonLinearSolver();
common/model_solver.cc:  return this->getSolver(solver_id).getNonLinearSolver();
common/model_solver.cc:    tmp_solver_id = this->default_solver_id;
common/model_solver.cc:  if (not this->dof_manager) {
common/model_solver.cc:  return this->dof_manager->hasTimeStepSolver(tmp_solver_id);
common/model_solver.cc:      this->hasSolver(solver_id),
common/model_solver.cc:  this->default_solver_id = solver_id;
common/model_solver.cc:  TimeStepSolver & tss = this->getSolver(solver_id);
common/model_solver.cc:  if (this->default_solver_id.empty()) {
common/model_solver.cc:    this->default_solver_id = solver_id;
common/model_solver.cc:  this->initSolver(time_step_solver_type, non_linear_solver_type);
common/model_solver.cc:  NonLinearSolver & nls = this->dof_manager->getNewNonLinearSolver(
common/model_solver.cc:  this->dof_manager->getNewTimeStepSolver(solver_id, time_step_solver_type, nls,
common/model_solver.cc:  const TimeStepSolver & tss = this->getSolver(solver_id);
common/model_solver.cc:  TimeStepSolver & tss = this->getSolver(solver_id);
common/model_solver.cc:  TimeStepSolver & tss = this->dof_manager->getTimeStepSolver(solver_id);
common/model_solver.cc:  TimeStepSolver & tss = this->dof_manager->getTimeStepSolver(solver_id);
common/model_solver.cc:  return (not this->default_solver_id.empty());
common/model_solver.cc:  TimeStepSolver & tss = this->dof_manager->getTimeStepSolver(solver_id);
common/integration_scheme/pseudo_time.cc:  auto & us = this->dof_manager.getDOFs(this->dof_id);
common/integration_scheme/pseudo_time.cc:  const auto & deltas = this->dof_manager.getSolution(this->dof_id);
common/integration_scheme/pseudo_time.cc:  const auto & blocked_dofs = this->dof_manager.getBlockedDOFs(this->dof_id);
common/integration_scheme/pseudo_time.cc:  SparseMatrix & J = this->dof_manager.getMatrix("J");
common/integration_scheme/pseudo_time.cc:  const SparseMatrix & K = this->dof_manager.getMatrix("K");
common/integration_scheme/pseudo_time.cc:  does_j_need_update |= this->dof_manager.hasBlockedDOFsChanged();
common/integration_scheme/generalized_trapezoidal.cc:  this->registerParam("alpha", this->alpha, alpha, _pat_parsmod,
common/integration_scheme/generalized_trapezoidal.cc:    this->allCorrector<_temperature>(delta_t, u, u_dot, blocked_dofs, delta);
common/integration_scheme/generalized_trapezoidal.cc:    this->allCorrector<_temperature_rate>(delta_t, u, u_dot, blocked_dofs,
common/integration_scheme/generalized_trapezoidal.cc:  SparseMatrix & J = this->dof_manager.getMatrix("J");
common/integration_scheme/generalized_trapezoidal.cc:  const SparseMatrix & M = this->dof_manager.getMatrix("M");
common/integration_scheme/generalized_trapezoidal.cc:  const SparseMatrix & K = this->dof_manager.getMatrix("K");
common/integration_scheme/generalized_trapezoidal.cc:  does_j_need_update |= this->dof_manager.hasBlockedDOFsChanged();
common/integration_scheme/generalized_trapezoidal.cc:  Real d = this->getTemperatureRateCoefficient(type, delta_t);
common/integration_scheme/generalized_trapezoidal.cc:  Real e = this->getTemperatureCoefficient(type, delta_t);
common/time_step_solvers/time_step_solver_default.cc:    this->is_mass_lumped = true;
common/time_step_solvers/time_step_solver_default.cc:  if (this->is_mass_lumped) {
common/time_step_solvers/time_step_solver_default.cc:  if (this->integration_schemes.find(dof_id) !=
common/time_step_solvers/time_step_solver_default.cc:      this->integration_schemes.end()) {
common/time_step_solvers/time_step_solver_default.cc:  this->integration_schemes[dof_id] = std::move(integration_scheme);
common/time_step_solvers/time_step_solver_default.cc:  this->solution_types[dof_id] = solution_type;
common/time_step_solvers/time_step_solver_default.cc:  this->integration_schemes_owner.insert(dof_id);
common/time_step_solvers/time_step_solver_default.cc:  return this->integration_schemes.find(dof_id) !=
common/time_step_solvers/time_step_solver_default.cc:         this->integration_schemes.end();
common/time_step_solvers/time_step_solver_default.cc:  this->solver_callback = &solver_callback;
common/time_step_solvers/time_step_solver_default.cc:  this->non_linear_solver.solve(*this);
common/time_step_solvers/time_step_solver_default.cc:  this->solver_callback = nullptr;
common/time_step_solvers/time_step_solver_default.cc:  for (auto && [dof_id, integration_scheme] : this->integration_schemes) {
common/time_step_solvers/time_step_solver_default.cc:    if (this->_dof_manager.hasPreviousDOFs(dof_id)) {
common/time_step_solvers/time_step_solver_default.cc:      this->_dof_manager.savePreviousDOFs(dof_id);
common/time_step_solvers/time_step_solver_default.cc:    integration_scheme->predictor(this->time_step);
common/time_step_solvers/time_step_solver_default.cc:  for (auto && [dof_id, integration_scheme] : this->integration_schemes) {
common/time_step_solvers/time_step_solver_default.cc:    const auto & solution_type = this->solution_types[dof_id];
common/time_step_solvers/time_step_solver_default.cc:    integration_scheme->corrector(solution_type, this->time_step);
common/time_step_solvers/time_step_solver_default.cc:    if (this->_dof_manager.hasDOFsIncrement(dof_id)) {
common/time_step_solvers/time_step_solver_default.cc:      if (not this->_dof_manager.hasPreviousDOFs(dof_id)) {
common/time_step_solvers/time_step_solver_default.cc:      auto & increment = this->_dof_manager.getDOFsIncrement(dof_id);
common/time_step_solvers/time_step_solver_default.cc:      auto & previous = this->_dof_manager.getPreviousDOFs(dof_id);
common/time_step_solvers/time_step_solver_default.cc:      auto dof_array_comp = this->_dof_manager.getDOFs(dof_id).getNbComponent();
common/time_step_solvers/time_step_solver_default.cc:        increment.copy(this->_dof_manager.getSolution(dof_id), true);
common/time_step_solvers/time_step_solver_default.cc:        increment.copy(this->_dof_manager.getDOFs(dof_id));
common/time_step_solvers/time_step_solver_default.cc:    const auto & solution_type = this->solution_types[dof_id];
common/time_step_solvers/time_step_solver_default.cc:    integration_scheme.assembleJacobian(solution_type, this->time_step);
common/time_step_solvers/time_step_solver_default.cc:  this->_dof_manager.applyBoundary("J");
common/time_step_solvers/time_step_solver_default.cc:  if (this->needed_matrices.find("M") != needed_matrices.end()) {
common/time_step_solvers/time_step_solver_default.cc:    if (this->is_mass_lumped) {
common/time_step_solvers/time_step_solver_default.cc:      this->assembleLumpedMatrix("M");
common/time_step_solvers/time_step_solver_default.cc:      this->assembleMatrix("M");
common/time_step_solvers/time_step_solver_default.cc:    integration_scheme.assembleResidual(this->is_mass_lumped);
common/time_step_solvers/time_step_solver_default.cc:  if (this->needed_matrices.find("M") != needed_matrices.end()) {
common/time_step_solvers/time_step_solver_default.cc:    if (this->is_mass_lumped) {
common/time_step_solvers/time_step_solver_default.cc:      this->assembleLumpedMatrix("M");
common/time_step_solvers/time_step_solver_default.cc:      this->assembleMatrix("M");
common/time_step_solvers/time_step_solver_default.cc:      integration_scheme.assembleResidual(this->is_mass_lumped);
common/time_step_solvers/time_step_solver_default.hh:    for (auto && [dof_id, integration_scheme] : this->integration_schemes) {
common/time_step_solvers/time_step_solver.cc:  this->registerSubRegistry("non_linear_solver", non_linear_solver);
common/time_step_solvers/time_step_solver.cc:  auto scheme = this->getIntegrationSchemeInternal(dof_id, type, solution_type);
common/time_step_solvers/time_step_solver.cc:  this->setIntegrationScheme(dof_id, scheme, solution_type);
common/time_step_solvers/time_step_solver.cc:  this->setIntegrationSchemeInternal(dof_id, scheme, solution_type);
common/time_step_solvers/time_step_solver.cc:      mat_type = this->solver_callback->getMatrixType(name);
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  this->solver_callback->predictor();
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  this->solver_callback->corrector();
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  this->solver_callback->beforeSolveStep();
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  this->solver_callback->afterSolveStep(converged);
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  this->solver_callback->assembleLumpedMatrix(matrix_id);
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  auto common_type = this->getCommonMatrixType();
common/time_step_solvers/time_step_solver.cc:    this->solver_callback->assembleMatrix(matrix_id);
common/time_step_solvers/time_step_solver.cc:    this->solver_callback->assembleMatrix(name);
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  this->_dof_manager.zeroResidual();
common/time_step_solvers/time_step_solver.cc:  this->solver_callback->assembleResidual();
common/time_step_solvers/time_step_solver.cc:      this->solver_callback != nullptr,
common/time_step_solvers/time_step_solver.cc:  this->solver_callback->assembleResidual(residual_part);
common/integration_scheme/newmark-beta.cc:  this->registerParam("alpha", this->alpha, alpha, _pat_parsmod,
common/integration_scheme/newmark-beta.cc:  this->registerParam("beta", this->beta, beta, _pat_parsmod,
common/integration_scheme/newmark-beta.cc:    this->allCorrector<_acceleration>(delta_t, u, u_dot, u_dot_dot,
common/integration_scheme/newmark-beta.cc:    this->allCorrector<_velocity>(delta_t, u, u_dot, u_dot_dot, blocked_dofs,
common/integration_scheme/newmark-beta.cc:    this->allCorrector<_displacement>(delta_t, u, u_dot, u_dot_dot,
common/integration_scheme/newmark-beta.cc:  auto & J = this->dof_manager.getMatrix("J");
common/integration_scheme/newmark-beta.cc:  const auto & M = this->dof_manager.getMatrix("M");
common/integration_scheme/newmark-beta.cc:  auto c = this->getAccelerationCoefficient(type, delta_t);
common/integration_scheme/newmark-beta.cc:  auto e = this->getDisplacementCoefficient(type, delta_t);
common/integration_scheme/newmark-beta.cc:    const auto & K = this->dof_manager.getMatrix("K");
common/integration_scheme/newmark-beta.cc:  if (this->dof_manager.hasMatrix("C")) {
common/integration_scheme/newmark-beta.cc:    const auto & C = this->dof_manager.getMatrix("C");
common/integration_scheme/newmark-beta.cc:  does_j_need_update |= this->dof_manager.hasBlockedDOFsChanged();
common/integration_scheme/newmark-beta.cc:    const auto & K = this->dof_manager.getMatrix("K");
common/integration_scheme/newmark-beta.cc:  if (this->dof_manager.hasMatrix("C")) {
common/integration_scheme/newmark-beta.cc:    auto d = this->getVelocityCoefficient(type, delta_t);
common/integration_scheme/newmark-beta.cc:    const auto & C = this->dof_manager.getMatrix("C");
common/integration_scheme/integration_scheme_1st_order.cc:  Array<Real> & u = this->dof_manager.getDOFs(this->dof_id);
common/integration_scheme/integration_scheme_1st_order.cc:  Array<Real> & u_dot = this->dof_manager.getDOFsDerivatives(this->dof_id, 1);
common/integration_scheme/integration_scheme_1st_order.cc:      this->dof_manager.getBlockedDOFs(this->dof_id);
common/integration_scheme/integration_scheme_1st_order.cc:  this->predictor(delta_t, u, u_dot, blocked_dofs);
common/integration_scheme/integration_scheme_1st_order.cc:  Array<Real> & u = this->dof_manager.getDOFs(this->dof_id);
common/integration_scheme/integration_scheme_1st_order.cc:  Array<Real> & u_dot = this->dof_manager.getDOFsDerivatives(this->dof_id, 1);
common/integration_scheme/integration_scheme_1st_order.cc:  const Array<Real> & solution = this->dof_manager.getSolution(this->dof_id);
common/integration_scheme/integration_scheme_1st_order.cc:      this->dof_manager.getBlockedDOFs(this->dof_id);
common/integration_scheme/integration_scheme_1st_order.cc:  this->corrector(type, delta_t, u, u_dot, blocked_dofs, solution);
common/integration_scheme/integration_scheme_1st_order.cc:      dof_manager.getDOFsDerivatives(this->dof_id, 1);
common/integration_scheme/integration_scheme_1st_order.cc:    if (this->dof_manager.hasMatrix("M")) {
common/integration_scheme/integration_scheme_1st_order.cc:      this->dof_manager.assembleMatMulVectToResidual(this->dof_id, "M",
common/integration_scheme/integration_scheme_1st_order.cc:    if (this->dof_manager.hasLumpedMatrix("M")) {
common/integration_scheme/integration_scheme_1st_order.cc:      this->dof_manager.assembleLumpedMatMulVectToResidual(
common/integration_scheme/integration_scheme_1st_order.cc:          this->dof_id, "M", first_derivative, -1);
common/integration_scheme/integration_scheme_2nd_order.cc:  Array<Real> & u = this->dof_manager.getDOFs(this->dof_id);
common/integration_scheme/integration_scheme_2nd_order.cc:  Array<Real> & u_dot = this->dof_manager.getDOFsDerivatives(this->dof_id, 1);
common/integration_scheme/integration_scheme_2nd_order.cc:      this->dof_manager.getDOFsDerivatives(this->dof_id, 2);
common/integration_scheme/integration_scheme_2nd_order.cc:      this->dof_manager.getBlockedDOFs(this->dof_id);
common/integration_scheme/integration_scheme_2nd_order.cc:  this->predictor(delta_t, u, u_dot, u_dot_dot, blocked_dofs);
common/integration_scheme/integration_scheme_2nd_order.cc:  Array<Real> & u = this->dof_manager.getDOFs(this->dof_id);
common/integration_scheme/integration_scheme_2nd_order.cc:  Array<Real> & u_dot = this->dof_manager.getDOFsDerivatives(this->dof_id, 1);
common/integration_scheme/integration_scheme_2nd_order.cc:      this->dof_manager.getDOFsDerivatives(this->dof_id, 2);
common/integration_scheme/integration_scheme_2nd_order.cc:  const Array<Real> & solution = this->dof_manager.getSolution(this->dof_id);
common/integration_scheme/integration_scheme_2nd_order.cc:      this->dof_manager.getBlockedDOFs(this->dof_id);
common/integration_scheme/integration_scheme_2nd_order.cc:  this->corrector(type, delta_t, u, u_dot, u_dot_dot, blocked_dofs, solution);
common/integration_scheme/integration_scheme_2nd_order.cc:  if (this->dof_manager.hasMatrix("C")) {
common/integration_scheme/integration_scheme_2nd_order.cc:        this->dof_manager.getDOFsDerivatives(this->dof_id, 1);
common/integration_scheme/integration_scheme_2nd_order.cc:    this->dof_manager.assembleMatMulVectToResidual(this->dof_id, "C",
common/integration_scheme/integration_scheme_2nd_order.cc:      this->dof_manager.getDOFsDerivatives(this->dof_id, 2);
common/integration_scheme/integration_scheme_2nd_order.cc:    this->dof_manager.assembleMatMulVectToResidual(this->dof_id, "M",
common/integration_scheme/integration_scheme_2nd_order.cc:    this->dof_manager.assembleLumpedMatMulVectToResidual(this->dof_id, "M",
model.cc:  this->mesh.registerEventHandler(*this, _ehp_model);
model.cc:  if (!this->hasDefaultSolver()) {
model.cc:    this->initNewSolver(this->method);
model.cc:  std::tie(solver_name, tss_type) = this->getDefaultSolverID(method);
model.cc:  if (not this->hasSolver(solver_name)) {
model.cc:    ModelSolverOptions options = this->getDefaultSolverOptions(tss_type);
model.cc:    this->getNewSolver(solver_name, tss_type, options.non_linear_solver_type);
model.cc:      if (!this->hasIntegrationScheme(solver_name, is_type.first)) {
model.cc:        this->setIntegrationScheme(solver_name, is_type.first, is_type.second,
model.cc:  this->method = method;
model.cc:  this->setDefaultSolver(solver_name);
model.cc:  this->addDumpFieldToDumper(mesh.getDefaultDumperName(), field_id);
model.cc:  this->addDumpFieldVectorToDumper(mesh.getDefaultDumperName(), field_id);
model.cc:  this->addDumpFieldTensorToDumper(mesh.getDefaultDumperName(), field_id);
model.cc:  this->addDumpGroupFieldToDumper(dumper_name, field_id, "all",
model.cc:  this->addDumpGroupFieldToDumper(group.getDefaultDumperName(), field_id,
model.cc:  this->removeDumpGroupFieldFromDumper(group.getDefaultDumperName(), field_id,
model.cc:  this->addDumpGroupFieldToDumper(dumper_name, field_id, "all",
model.cc:  this->addDumpGroupFieldVectorToDumper(group.getDefaultDumperName(), field_id,
model.cc:  this->addDumpGroupFieldToDumper(dumper_name, field_id, group_name,
model.cc:  this->addDumpGroupFieldToDumper(dumper_name, field_id, "all",
model.cc:  this->addDumpGroupFieldToDumper(dumper_name, field_id, group_name,
model.cc:                                  this->spatial_dimension, element_kind,
model.cc:    field = this->createNodalFieldReal(field_id, group_name, padding_flag);
model.cc:    field = this->createNodalFieldInt(field_id, group_name, padding_flag);
model.cc:    field = this->createNodalFieldBool(field_id, group_name, padding_flag);
model.cc:    field = this->createElementalField(field_id, group_name, padding_flag,
model.cc:    field = this->mesh.createFieldFromAttachedData<Int>(field_id, group_name,
model.cc:    field = this->mesh.createFieldFromAttachedData<Real>(field_id, group_name,
model.cc:    this->addDumpGroupFieldToDumper(field_id, field, dumper);
model.cc:  this->dump(default_dumper);
model.cc:  this->dump(default_dumper, step);
model.cc:  this->dump(default_dumper, time, step);
structural_mechanics/structural_mechanics_model.cc:  this->mesh.registerDumper<DumperParaview>("structural_mechanics_model", id,
structural_mechanics/structural_mechanics_model.cc:  this->mesh.addDumpMesh(mesh, spatial_dimension, _not_ghost, _ek_structural);
structural_mechanics/structural_mechanics_model.cc:  this->initDOFManager();
structural_mechanics/structural_mechanics_model.cc:  this->dumper_default_element_kind = _ek_structural;
structural_mechanics/structural_mechanics_model.cc:  this->mesh.getDumper().setTimeStep(time_step);
structural_mechanics/structural_mechanics_model.cc:  this->allocNodalField(displacement_rotation, nb_degree_of_freedom,
structural_mechanics/structural_mechanics_model.cc:  this->allocNodalField(external_force, nb_degree_of_freedom, "external_force");
structural_mechanics/structural_mechanics_model.cc:  this->allocNodalField(internal_force, nb_degree_of_freedom, "internal_force");
structural_mechanics/structural_mechanics_model.cc:  this->allocNodalField(blocked_dofs, nb_degree_of_freedom, "blocked_dofs");
structural_mechanics/structural_mechanics_model.cc:  auto & dof_manager = this->getDOFManager();
structural_mechanics/structural_mechanics_model.cc:    dof_manager.registerBlockedDOFs("displacement", *this->blocked_dofs);
structural_mechanics/structural_mechanics_model.cc:    this->allocNodalField(velocity, nb_degree_of_freedom, "velocity");
structural_mechanics/structural_mechanics_model.cc:    this->allocNodalField(acceleration, nb_degree_of_freedom, "acceleration");
structural_mechanics/structural_mechanics_model.cc:      dof_manager.registerDOFsDerivative("displacement", 1, *this->velocity);
structural_mechanics/structural_mechanics_model.cc:                                         *this->acceleration);
structural_mechanics/structural_mechanics_model.cc:      this->allocateLumpedMassArray();
structural_mechanics/structural_mechanics_model.cc:  this->getDOFManager().zeroMatrix("K");
structural_mechanics/structural_mechanics_model.cc:          this->assembleStiffnessMatrix<type>();
structural_mechanics/structural_mechanics_model.cc:          this->computeStressOnQuad<type>();
structural_mechanics/structural_mechanics_model.cc:  this->allocNodalField(this->mass, this->nb_degree_of_freedom, "lumped_mass");
structural_mechanics/structural_mechanics_model.cc:    AKANTU_DEBUG_ASSERT(this->mass.get() != nullptr,
structural_mechanics/structural_mechanics_model.cc:    return mesh.createStridedNodalField(this->mass.get(), group_name, n, 0,
structural_mechanics/structural_mechanics_model.cc:    ElementTypeMap<Int> nb_data_per_elem = this->mesh.getNbDataPerElem(stress);
structural_mechanics/structural_mechanics_model.cc:        stress, group_name, this->spatial_dimension, kind, nb_data_per_elem);
structural_mechanics/structural_mechanics_model.cc:    this->assembleLumpedMassMatrix();
structural_mechanics/structural_mechanics_model.cc:  auto & dof_manager = this->getDOFManager();
structural_mechanics/structural_mechanics_model.cc:    dof_manager.assembleToResidual("displacement", *this->external_force, 1);
structural_mechanics/structural_mechanics_model.cc:    this->assembleInternalForce();
structural_mechanics/structural_mechanics_model.cc:    dof_manager.assembleToResidual("displacement", *this->internal_force, 1);
structural_mechanics/structural_mechanics_model.cc:    if (this->method == _explicit_consistent_mass) {
structural_mechanics/structural_mechanics_model.cc:  const UInt nb_degree_of_freedom = this->nb_degree_of_freedom;
structural_mechanics/structural_mechanics_model.cc:  if (this->getDOFManager().hasLumpedMatrix("M")) {
structural_mechanics/structural_mechanics_model.cc:    AKANTU_DEBUG_ASSERT(this->mass != nullptr,
structural_mechanics/structural_mechanics_model.cc:    this->assembleLumpedMatrix("M");
structural_mechanics/structural_mechanics_model.cc:         zip(arange(nb_nodes), make_view(*this->velocity, nb_degree_of_freedom),
structural_mechanics/structural_mechanics_model.cc:             make_view(*this->mass, nb_degree_of_freedom))) {
structural_mechanics/structural_mechanics_model.cc:  } else if (this->getDOFManager().hasMatrix("M")) {
structural_mechanics/structural_mechanics_model.cc:    this->assembleMassMatrix();
structural_mechanics/structural_mechanics_model.cc:    this->getDOFManager().assembleMatMulVectToArray("displacement", "M",
structural_mechanics/structural_mechanics_model.cc:                                                    *this->velocity, Mv);
structural_mechanics/structural_mechanics_model.cc:             make_view(*this->velocity, nb_degree_of_freedom))) {
structural_mechanics/structural_mechanics_model.cc:  this->assembleStiffnessMatrix();
structural_mechanics/structural_mechanics_model.cc:  this->getDOFManager().assembleMatMulVectToArray(
structural_mechanics/structural_mechanics_model.cc:      "displacement", "K", *this->displacement_rotation, Ku);
structural_mechanics/structural_mechanics_model.cc:           make_view(*this->displacement_rotation, nb_degree_of_freedom))) {
model_couplers/coupler_solid_cohesive_contact.cc:  this->initDOFManager(dof_manager);
model_couplers/coupler_solid_cohesive_contact.cc:  this->mesh.registerDumper<DumperParaview>("coupler_solid_cohesive_contact",
model_couplers/coupler_solid_cohesive_contact.cc:  this->mesh.addDumpMeshToDumper("coupler_solid_cohesive_contact", mesh,
model_couplers/coupler_solid_cohesive_contact.cc:  this->registerDataAccessor(*this);
model_couplers/coupler_solid_cohesive_contact.cc:      this->dof_manager);
phase_field/phase_field_model.hh:    this->setConstitutiveLawSelector(selector);
phase_field/phasefield.cc:      g_c(this->registerInternal<Real, DefaultRandomInternalField>(
phase_field/phasefield.cc:      damage_on_qpoints(this->registerInternal("damage", 1, fe_engine_id)),
phase_field/phasefield.cc:      gradd(this->registerInternal("grad_d", spatial_dimension, fe_engine_id)),
phase_field/phasefield.cc:      phi(this->registerInternal("phi", 1, fe_engine_id)),
phase_field/phasefield.cc:      strain(this->registerInternal(
phase_field/phasefield.cc:      driving_force(this->registerInternal("driving_force", 1, fe_engine_id)),
phase_field/phasefield.cc:      driving_energy(this->registerInternal("driving_energy", spatial_dimension,
phase_field/phasefield.cc:      damage_energy(this->registerInternal(
phase_field/phasefield.cc:          this->registerInternal("damage_energy_density", 1, fe_engine_id)),
phase_field/phasefield.cc:          this->registerInternal("dissipated_energy", 1, fe_engine_id)) {
phase_field/phasefield.cc:  this->phi.initializeHistory();
phase_field/phasefield.cc:  this->damage_on_qpoints.initializeHistory();
phase_field/phasefield.cc:  this->registerParam("l0", l0, Real(0.), _pat_parsable | _pat_readable,
phase_field/phasefield.cc:  this->registerParam("gc", g_c, _pat_parsable | _pat_readable,
phase_field/phasefield.cc:  this->registerParam("E", E, _pat_parsable | _pat_readable, "Young's modulus");
phase_field/phasefield.cc:  this->registerParam("nu", nu, _pat_parsable | _pat_readable, "Poisson ratio");
phase_field/phasefield.cc:  this->registerParam("isotropic", isotropic, true,
phase_field/phasefield.cc:  this->lambda = this->nu * this->E / ((1 + this->nu) * (1 - 2 * this->nu));
phase_field/phasefield.cc:  if (this->plane_stress) {
phase_field/phasefield.cc:    this->lambda = this->nu * this->E / ((1 + this->nu) * (1 - this->nu));
phase_field/phasefield.cc:  this->mu = this->E / (2 * (1 + this->nu));
phase_field/phasefield.cc:  auto & fem = this->getFEEngine();
phase_field/phasefield.cc:  for (const auto & type : this->getElementFilter().elementTypes(
phase_field/phasefield.cc:           this->spatial_dimension, ghost_type)) {
phase_field/phasefield.cc:    auto & elem_filter = this->getElementFilter(type, ghost_type);
phase_field/phasefield.cc:  auto & fem = this->getFEEngine();
phase_field/phasefield.cc:  auto & fem = this->getFEEngine();
phase_field/phasefield.cc:  auto & fem = this->getFEEngine();
phase_field/phasefield.cc:  auto & fem = this->getFEEngine();
phase_field/phasefield.cc:  auto & fem = this->getFEEngine();
phase_field/phasefield.cc:  // this->savePreviousState();
phase_field/phasefield.cc:  this->computeAllDrivingForces(_not_ghost);
model_couplers/coupler_solid_phasefield.cc:  this->registerFEEngineObject<MyFEEngineType>("CouplerSolidPhaseField", mesh,
model_couplers/coupler_solid_phasefield.cc:  this->mesh.registerDumper<DumperParaview>("coupler_solid_phasefield", id,
model_couplers/coupler_solid_phasefield.cc:  this->mesh.addDumpMeshToDumper("coupler_solid_phasefield", mesh,
model_couplers/coupler_solid_phasefield.cc:  this->registerDataAccessor(*this);
model_couplers/coupler_solid_phasefield.cc:  if (this->mesh.isDistributed()) {
model_couplers/coupler_solid_phasefield.cc:    auto & synchronizer = this->mesh.getElementSynchronizer();
model_couplers/coupler_solid_phasefield.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_csp_damage);
model_couplers/coupler_solid_phasefield.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_csp_strain);
model_couplers/coupler_solid_phasefield.cc:  this->initBC(*this, *displacement, *displacement_increment, *external_force);
model_couplers/coupler_solid_phasefield.cc:  solid->initFull(_analysis_method = this->method);
model_couplers/coupler_solid_phasefield.cc:  phase->initFull(_analysis_method = this->method);
model_couplers/coupler_solid_phasefield.cc:  this->assembleInternalForces();
model_couplers/coupler_solid_phasefield.cc:  this->getDOFManager().assembleToResidual("displacement", solid_external_force,
model_couplers/coupler_solid_phasefield.cc:  this->getDOFManager().assembleToResidual("displacement", solid_internal_force,
model_couplers/coupler_solid_phasefield.cc:  this->getDOFManager().assembleToResidual("damage", phasefield_external_force,
model_couplers/coupler_solid_phasefield.cc:  this->getDOFManager().assembleToResidual("damage", phasefield_internal_force,
model_couplers/coupler_solid_phasefield.cc:    this->getDOFManager().assembleToResidual("displacement",
model_couplers/coupler_solid_phasefield.cc:    this->getDOFManager().assembleToResidual("displacement",
model_couplers/coupler_solid_phasefield.cc:    this->getDOFManager().assembleToResidual("damage",
model_couplers/coupler_solid_phasefield.cc:    this->getDOFManager().assembleToResidual("damage",
model_couplers/coupler_solid_phasefield.cc:    this->assembleStiffnessMatrix();
model_couplers/coupler_solid_phasefield.cc:                   mesh.elementTypes(this->spatial_dimension, ghost_type)) {
model_couplers/coupler_solid_phasefield.cc:            this->spatial_dimension);
model_couplers/coupler_solid_phasefield.cc:  this->computeStrainOnQuadPoints(_not_ghost);
model_couplers/coupler_solid_phasefield.cc:  this->computeStrainOnQuadPoints(_ghost);
model_couplers/coupler_solid_phasefield.cc:  this->computeDamageOnQuadPoints(_not_ghost);
model_couplers/coupler_solid_phasefield.cc:  this->computeDamageOnQuadPoints(_ghost);
model_couplers/coupler_solid_contact.cc:  this->initDOFManager(dof_manager);
model_couplers/coupler_solid_contact.cc:  this->mesh.registerDumper<DumperParaview>("coupler_solid_contact", id, true);
model_couplers/coupler_solid_contact.cc:  this->mesh.addDumpMeshToDumper("coupler_solid_contact", mesh,
model_couplers/coupler_solid_contact.cc:  this->registerDataAccessor(*this);
model_couplers/coupler_solid_contact.cc:                                                this->dof_manager);
model_couplers/coupler_solid_contact.cc:      this->dof_manager);
model_couplers/coupler_solid_contact.cc:  solid->initFull(_analysis_method = this->method);
model_couplers/coupler_solid_contact.cc:  contact->initFull(_analysis_method = this->method);
phase_field/phasefield.hh:  void initConstitutiveLaw() override { this->initPhaseField(); }
model_couplers/coupler_solid_contact_tmpl.hh:  this->assembleInternalForces();
model_couplers/coupler_solid_contact_tmpl.hh:  this->getDOFManager().assembleToResidual("displacement", external_force, 1);
model_couplers/coupler_solid_contact_tmpl.hh:  this->getDOFManager().assembleToResidual("displacement", internal_force, 1);
model_couplers/coupler_solid_contact_tmpl.hh:  this->getDOFManager().assembleToResidual("displacement", contact_force, 1);
model_couplers/coupler_solid_contact_tmpl.hh:    this->getDOFManager().assembleToResidual("displacement", external_force, 1);
model_couplers/coupler_solid_contact_tmpl.hh:    this->getDOFManager().assembleToResidual("displacement", contact_force, 1);
model_couplers/coupler_solid_contact_tmpl.hh:    this->getDOFManager().assembleToResidual("displacement", internal_force, 1);
model_couplers/coupler_solid_contact_tmpl.hh:    this->assembleStiffnessMatrix();
structural_mechanics/structural_mechanics_model.hh:    if (this->mass == nullptr) {
structural_mechanics/structural_mechanics_model.hh:    return *(this->mass);
structural_mechanics/structural_mechanics_model.hh:  inline const Array<Real> & getMass() const { return this->getLumpedMass(); }
structural_mechanics/structural_mechanics_model.hh:  inline bool hasLumpedMass() const { return (this->mass != nullptr); };
phase_field/phase_field_model.cc:  this->initDOFManager(std::move(dof_manager));
phase_field/phase_field_model.cc:  this->registerFEEngineObject<FEEngineType>("PhaseFieldFEEngine", mesh,
phase_field/phase_field_model.cc:  this->mesh.registerDumper<DumperParaview>("phase_field", id, true);
phase_field/phase_field_model.cc:  this->mesh.addDumpMesh(mesh, Model::spatial_dimension, _not_ghost,
phase_field/phase_field_model.cc:  if (this->mesh.isDistributed()) {
phase_field/phase_field_model.cc:    auto & synchronizer = this->mesh.getElementSynchronizer();
phase_field/phase_field_model.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_pfm_damage);
phase_field/phase_field_model.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_for_dump);
phase_field/phase_field_model.cc:  this->parser_type = ParserType::_phasefield;
phase_field/phase_field_model.cc:  this->initBC(*this, *damage, *external_force);
phase_field/phase_field_model.cc:    this->assembleStiffnessMatrix();
phase_field/phase_field_model.cc:  DOFManager & dof_manager = this->getDOFManager();
phase_field/phase_field_model.cc:  this->allocNodalField(this->damage, 1, "damage");
phase_field/phase_field_model.cc:  this->allocNodalField(this->external_force, 1, "external_force");
phase_field/phase_field_model.cc:  this->allocNodalField(this->internal_force, 1, "internal_force");
phase_field/phase_field_model.cc:  this->allocNodalField(this->blocked_dofs, 1, "blocked_dofs");
phase_field/phase_field_model.cc:  this->allocNodalField(this->previous_damage, 1, "previous_damage");
phase_field/phase_field_model.cc:    dof_manager.registerDOFs("damage", *this->damage, _dst_nodal);
phase_field/phase_field_model.cc:    dof_manager.registerBlockedDOFs("damage", *this->blocked_dofs);
phase_field/phase_field_model.cc:    dof_manager.registerDOFsPrevious("damage", *this->previous_damage);
phase_field/phase_field_model.cc:  auto phase_index = this->getConstitutiveLawByElement()(element);
phase_field/phase_field_model.cc:  pf_element.element = this->getConstitutiveLawLocalNumbering()(element);
phase_field/phase_field_model.cc:      this->getConstitutiveLaw(phase_index).getEnergy(energy_id, pf_element);
phase_field/phase_field_model.cc:      energy += this->getEnergy(energy_id, el);
phase_field/phase_field_model.cc:  if (!this->getDOFManager().hasMatrix("K")) {
phase_field/phase_field_model.cc:    this->getDOFManager().getNewMatrix("K", getMatrixType("K"));
phase_field/phase_field_model.cc:  this->getDOFManager().zeroMatrix("K");
phase_field/phase_field_model.cc:  this->assembleInternalForces();
phase_field/phase_field_model.cc:  this->getDOFManager().assembleToResidual("damage", *this->external_force, 1);
phase_field/phase_field_model.cc:  this->getDOFManager().assembleToResidual("damage", *this->internal_force, 1);
phase_field/phase_field_model.cc:  this->internal_force->zero();
phase_field/phase_field_model.cc:  this->synchronize(SynchronizationTag::_pfm_damage);
phase_field/phase_field_model.cc:  this->mesh.getDumper("phase_field").setTimeStep(time_step);
phase_field/phase_field_model.cc:        mesh.getConnectivities(), group_name, this->spatial_dimension,
structural_mechanics/structural_mechanics_model_mass.cc:  this->getDOFManager().zeroMatrix("M");
structural_mechanics/structural_mechanics_model_mass.cc:                            this->getDOFManager(), type, ghost_type);
structural_mechanics/structural_mechanics_model_mass.cc:  if (not this->need_to_reassemble_lumped_mass) {
structural_mechanics/structural_mechanics_model_mass.cc:  allocNodalField(this->mass, nb_degree_of_freedom, "lumped_mass");
structural_mechanics/structural_mechanics_model_mass.cc:  if (!this->getDOFManager().hasLumpedMatrix("M")) {
structural_mechanics/structural_mechanics_model_mass.cc:    this->getDOFManager().getNewLumpedMatrix("M");
structural_mechanics/structural_mechanics_model_mass.cc:  this->getDOFManager().zeroLumpedMatrix("M");
structural_mechanics/structural_mechanics_model_mass.cc:  auto & lumped_mass = *(this->mass);
structural_mechanics/structural_mechanics_model_mass.cc:    const auto & element_material_id = this->element_material(type);
structural_mechanics/structural_mechanics_model_mass.cc:      const auto & material = this->materials.at(std::get<1>(data));
structural_mechanics/structural_mechanics_model_mass.cc:  this->getDOFManager().assembleToLumpedMatrix("displacement", lumped_mass,
structural_mechanics/structural_mechanics_model_mass.cc:  this->need_to_reassemble_lumped_mass = false;
model.hh:    switch (this->model_type) {
model.hh:      this->initFullImpl(SolidMechanicsModelOptions{
model.hh:      this->initFullImpl(SolidMechanicsModelCohesiveOptions{
model.hh:      this->initFullImpl(HeatTransferModelOptions{
model.hh:      this->initFullImpl(PhaseFieldModelOptions{
model.hh:      this->initFullImpl(EmbeddedInterfaceModelOptions{
model.hh:      this->initFullImpl(ContactMechanicsModelOptions{
model.hh:      this->initFullImpl(CouplerSolidContactOptions{
model.hh:      this->initFullImpl(CouplerSolidCohesiveContactOptions{
model.hh:      this->initFullImpl(ModelOptions{use_named_args,
model.hh:    this->initFullImpl(std::forward<decltype(_pack)>(_pack)...);
phase_field/phasefields/phasefield_linear_inline_impl.hh:    edis += 3. / 8 * g_c_quad * this->l0 * grad_d[i] * grad_d[i];
phase_field/phasefields/phasefield_linear_inline_impl.hh:  edis += 3 * g_c_quad * dam * dam / (8 * this->l0);
phase_field/phasefields/phasefield_linear_inline_impl.hh:  edis += 0.5 * this->gamma * damage_penalized * damage_penalized;
phase_field/phasefields/phasefield_linear_inline_impl.hh:  driving_force_quad = phi_quad - 3 * g_c_quad / (16 * this->l0);
phase_field/phasefields/phasefield_linear_inline_impl.hh:  Real kpa = this->lambda + 2. * this->mu / Real(dev_dim);
phase_field/phasefields/phasefield_linear_inline_impl.hh:             this->mu * strain_dev.doubleDot(strain_dev);
phase_field/phasefields/phasefield_linear_inline_impl.hh:  phi_quad = 0.5 * this->lambda * trace * trace +
phase_field/phasefields/phasefield_linear_inline_impl.hh:             this->mu * strain_quad.doubleDot(strain_quad);
diffusion_model/diffusion_law.cc:  this->getFEEngine().gradientOnIntegrationPoints(
diffusion_model/diffusion_law.cc:    this->computeGradU(type, ghost_type);
diffusion_model/diffusion_law.cc:    this->computeDiffusivityGradUOnQuadPoints(type, ghost_type);
diffusion_model/diffusion_law.cc:  auto && model = this->getHandler();
diffusion_model/diffusion_law.cc:  auto & fem = this->getFEEngine();
diffusion_model/diffusion_law.cc:  auto & model = this->getHandler();
diffusion_model/diffusion_law.cc:    packElementalDataHelper(this->grad_u, buffer, elements,
diffusion_model/diffusion_law.cc:                            this->getFEEngine());
solid_mechanics/solid_mechanics_model_mass.cc:  this->allocNodalField(this->mass, spatial_dimension, "mass");
solid_mechanics/solid_mechanics_model_mass.cc:  if (!this->getDOFManager().hasLumpedMatrix("M")) {
solid_mechanics/solid_mechanics_model_mass.cc:    this->getDOFManager().getNewLumpedMatrix("M");
solid_mechanics/solid_mechanics_model_mass.cc:  this->getDOFManager().zeroLumpedMatrix("M");
solid_mechanics/solid_mechanics_model_mass.cc:  this->getDOFManager().getLumpedMatrixPerDOFs("displacement", "M",
solid_mechanics/solid_mechanics_model_mass.cc:                                               *(this->mass));
solid_mechanics/solid_mechanics_model_mass.cc:  this->synchronize(SynchronizationTag::_smm_mass);
solid_mechanics/solid_mechanics_model_mass.cc:  if (not this->getDOFManager().hasMatrix("M")) {
solid_mechanics/solid_mechanics_model_mass.cc:    this->getDOFManager().getNewMatrix("M", this->getMatrixType("M"));
solid_mechanics/solid_mechanics_model_mass.cc:  this->getDOFManager().zeroMatrix("M");
solid_mechanics/solid_mechanics_model_mass.cc:                            this->getDOFManager(), type, ghost_type);
solid_mechanics/solid_mechanics_model_mass.cc:                            this->getDOFManager(), type, ghost_type);
common/non_linear_solver/non_linear_solver_petsc.cc:  this->has_internal_set_param = true;
common/non_linear_solver/non_linear_solver_petsc.cc:  this->checkIfTypeIsSupported();
common/non_linear_solver/non_linear_solver_petsc.cc:  void setCallback(SolverCallback & callback) { this->callback = &callback; }
common/non_linear_solver/non_linear_solver_petsc.cc:  _this->assembleResidual(x);
common/non_linear_solver/non_linear_solver_petsc.cc:  _this->assembleJacobian(x);
common/non_linear_solver/non_linear_solver_petsc.cc:  this->dof_manager.updateGlobalBlockedDofs();
common/non_linear_solver/non_linear_solver_petsc.cc:        this->reason, this->n_iter, stol, atol, rtol, maxit));
solid_mechanics/material.hh:  void initConstitutiveLaw() override { this->initMaterial(); }
solid_mechanics/material.hh:    return this->getHandler();
solid_mechanics/material.hh:  [[nodiscard]] SolidMechanicsModel & getModel() { return this->getHandler(); }
solid_mechanics/material.hh:      make_view(this->gradu(el_type, ghost_type), this->spatial_dimension,     \
solid_mechanics/material.hh:                this->spatial_dimension);                                      \
solid_mechanics/material.hh:      make_view(this->stress(el_type, ghost_type), this->spatial_dimension,    \
solid_mechanics/material.hh:                this->spatial_dimension);                                      \
solid_mechanics/material.hh:  if (this->isFiniteDeformation()) {                                           \
solid_mechanics/material.hh:    stress_view = make_view((*this->piola_kirchhoff_2)(el_type, ghost_type),   \
solid_mechanics/material.hh:                            this->spatial_dimension, this->spatial_dimension); \
solid_mechanics/material.hh:      make_view(this->gradu(el_type, ghost_type), this->spatial_dimension,     \
solid_mechanics/material.hh:                this->spatial_dimension);                                      \
solid_mechanics/material.hh:      make_view(this->stress(el_type, ghost_type), this->spatial_dimension,    \
solid_mechanics/material.hh:                this->spatial_dimension);                                      \
solid_mechanics/material.hh:      Material::getTangentStiffnessVoigtSize(this->spatial_dimension);         \
solid_mechanics/solid_mechanics_model.hh:  inline decltype(auto) getMaterials() { return this->getConstitutiveLaws(); }
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLaws();
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLaw(mat_index);
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLaw(mat_index);
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLaw(name);
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLaw(name);
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLaw(element);
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLawIndex(name);
solid_mechanics/solid_mechanics_model.hh:    return this->getNbConstitutiveLaws();
solid_mechanics/solid_mechanics_model.hh:  void reassignMaterial() { this->reassignConstitutiveLaw(); }
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLawByElement();
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLawLocalNumbering();
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLawByElement(type, ghost_type);
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLawLocalNumbering(type, ghost_type);
solid_mechanics/solid_mechanics_model.hh:    return this->getConstitutiveLawSelector();
solid_mechanics/solid_mechanics_model.hh:    this->setConstitutiveLawSelector(material_selector);
solid_mechanics/material.cc:  this->getModel().registerEventHandler(*this);
solid_mechanics/material.cc:    this->registerInternal("piola_kirchhoff_2",
solid_mechanics/material.cc:    this->piola_kirchhoff_2 = this->getSharedPtrInternal("piola_kirchhoff_2");
solid_mechanics/material.cc:    this->piola_kirchhoff_2->initializeHistory();
solid_mechanics/material.cc:    this->registerInternal("green_strain",
solid_mechanics/material.cc:    this->green_strain = this->getSharedPtrInternal("green_strain");
solid_mechanics/material.cc:  this->stress.initializeHistory();
solid_mechanics/material.cc:  this->gradu.initializeHistory();
solid_mechanics/material.cc:            this->assembleInternalForces<dim>(type, ghost_type);
solid_mechanics/material.cc:            this->assembleInternalForcesFiniteDeformation<dim>(type,
solid_mechanics/material.cc:          this->StoCauchy<dim>(type, ghost_type);
solid_mechanics/material.cc:       zip(make_view<dim, dim>(this->gradu(el_type, ghost_type)),
solid_mechanics/material.cc:           make_view<dim, dim>((*this->piola_kirchhoff_2)(el_type, ghost_type)),
solid_mechanics/material.cc:           make_view<dim, dim>(this->stress(el_type, ghost_type)))) {
solid_mechanics/material.cc:    this->StoCauchy<dim>(F, piola, sigma);
solid_mechanics/material.cc:            this->assembleStiffnessMatrixFiniteDeformation<dim>(type,
solid_mechanics/material.cc:            this->assembleStiffnessMatrix<dim>(type, ghost_type);
solid_mechanics/material.cc:        this->assembleStiffnessMatrix<dim, type>(ghost_type);
solid_mechanics/material.cc:        this->assembleStiffnessMatrixNL<dim, type>(ghost_type);
solid_mechanics/material.cc:        this->assembleStiffnessMatrixL2<dim, type>(ghost_type);
solid_mechanics/material.cc:        this->assembleInternalForces<dim, type>(ghost_type);
solid_mechanics/material.cc:  auto && fem = this->getFEEngine();
solid_mechanics/material.cc:        this->assembleInternalForcesFiniteDeformation<dim, type>(ghost_type);
solid_mechanics/material.cc:       zip(make_view<dim, dim>(this->gradu(type, ghost_type)),
solid_mechanics/material.cc:           make_view<dim, dim>((*this->piola_kirchhoff_2)(type, ghost_type)),
solid_mechanics/material.cc:      interpolation_points_coordinates, this->interpolation_points_matrices,
solid_mechanics/material.cc:      this->interpolation_inverse_coordinates, &(this->getElementFilter()));
solid_mechanics/material.cc:      this->stress, this->interpolation_points_matrices,
solid_mechanics/material.cc:      this->interpolation_inverse_coordinates, result, ghost_type,
solid_mechanics/material.cc:      &(this->getElementFilter()));
solid_mechanics/material.cc:  auto stress_size = this->stress.getNbComponent();
solid_mechanics/material.cc:  const auto & mesh = this->getModel().getMesh();
solid_mechanics/material.cc:void Material::beforeSolveStep() { this->savePreviousState(); }
solid_mechanics/material.cc:    this->restorePreviousState();
solid_mechanics/material.cc:    this->updateEnergies(type);
solid_mechanics/material.cc:void Material::onDamageIteration() { this->savePreviousState(); }
solid_mechanics/material.cc:    this->updateEnergiesAfterDamage(type);
solid_mechanics/material.cc:  if (this->isFiniteDeformation()) {
solid_mechanics/material.cc:    this->computeAllCauchyStresses(_not_ghost);
solid_mechanics/material.cc:  if (this->isInternal<Real>(id, element.kind())) {
solid_mechanics/material.cc:    auto name = this->getID() + ":" + id;
solid_mechanics/material.cc:        this->getInternal<Real>(name).getFEEngine().getNbIntegrationPoints(
solid_mechanics/material.cc:        this->getArray<Real>(id, element.type, element.ghost_type);
solid_mechanics/material.cc:    auto local_element = this->convertToLocalElement(element);
solid_mechanics/material.cc:    for (auto & eigengradu : make_view(this->eigengradu(type, ghost_type),
solid_mechanics/solid_mechanics_model_io.cc:  this->flattenAllRegisteredInternals(_ek_regular);
solid_mechanics/solid_mechanics_model_io.cc:    bool is_internal = this->isInternal(field_name_copy, kind);
solid_mechanics/solid_mechanics_model_io.cc:          this->getInternalDataPerElem(field_name_copy, kind);
solid_mechanics/solid_mechanics_model_io.cc:      auto & internal_flat = this->flattenInternal(field_name_copy, kind);
solid_mechanics/solid_mechanics_model_io.cc:  real_nodal_fields["displacement"] = this->displacement.get();
solid_mechanics/solid_mechanics_model_io.cc:  real_nodal_fields["mass"] = this->mass.get();
solid_mechanics/solid_mechanics_model_io.cc:  real_nodal_fields["velocity"] = this->velocity.get();
solid_mechanics/solid_mechanics_model_io.cc:  real_nodal_fields["acceleration"] = this->acceleration.get();
solid_mechanics/solid_mechanics_model_io.cc:  real_nodal_fields["external_force"] = this->external_force.get();
solid_mechanics/solid_mechanics_model_io.cc:  real_nodal_fields["internal_force"] = this->internal_force.get();
solid_mechanics/solid_mechanics_model_io.cc:  real_nodal_fields["increment"] = this->displacement_increment.get();
solid_mechanics/solid_mechanics_model_io.cc:    field = this->mesh.createNodalField(real_nodal_fields[field_name],
solid_mechanics/solid_mechanics_model_io.cc:        this->mesh.createNodalField(real_nodal_fields[field_name], group_name);
solid_mechanics/solid_mechanics_model_io.cc:  this->onDump();
solid_mechanics/solid_mechanics_model_io.cc:  this->onDump();
solid_mechanics/solid_mechanics_model_io.cc:  this->onDump();
solid_mechanics/solid_mechanics_model_io.cc:  this->onDump();
solid_mechanics/solid_mechanics_model_io.cc:  this->onDump();
solid_mechanics/solid_mechanics_model_io.cc:  this->onDump();
diffusion_model/diffusion_model.cc:  this->initDOFManager(dof_manager);
diffusion_model/diffusion_model.cc:  if (this->mesh.isDistributed()) {
diffusion_model/diffusion_model.cc:    auto & synchronizer = this->mesh.getElementSynchronizer();
diffusion_model/diffusion_model.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_diffusion);
diffusion_model/diffusion_model.cc:    this->registerSynchronizer(synchronizer,
diffusion_model/diffusion_model.cc:  this->mesh.registerDumper<DumperParaview>(id, id, true);
diffusion_model/diffusion_model.cc:  this->mesh.addDumpMesh(mesh, spatial_dimension, _not_ghost, _ek_regular);
diffusion_model/diffusion_model.cc:    this->assembleDiffisivityMatrix();
diffusion_model/diffusion_model.cc:    this->assembleCapacityMatrix();
diffusion_model/diffusion_model.cc:    this->assembleCapacityMatrixLumped();
diffusion_model/diffusion_model.cc:  this->assembleInternalFlow();
diffusion_model/diffusion_model.cc:  this->getDOFManager().assembleToResidual(dof_name, *this->external_flow, 1);
diffusion_model/diffusion_model.cc:  this->getDOFManager().assembleToResidual(dof_name, *this->internal_flow, 1);
diffusion_model/diffusion_model.cc:  DOFManager & dof_manager = this->getDOFManager();
diffusion_model/diffusion_model.cc:  this->allocNodalField(this->diffusion, 1, dof_name);
diffusion_model/diffusion_model.cc:  this->allocNodalField(this->external_flow, 1, "external_flow");
diffusion_model/diffusion_model.cc:  this->allocNodalField(this->internal_flow, 1, "internal_flow");
diffusion_model/diffusion_model.cc:  this->allocNodalField(this->blocked_dofs, 1, "blocked_dofs");
diffusion_model/diffusion_model.cc:    dof_manager.registerDOFs(dof_name, *this->diffusion, _dst_nodal);
diffusion_model/diffusion_model.cc:    dof_manager.registerBlockedDOFs(dof_name, *this->blocked_dofs);
diffusion_model/diffusion_model.cc:    this->allocNodalField(this->diffusion_rate, 1, dof_name + "_rate");
diffusion_model/diffusion_model.cc:      dof_manager.registerDOFsDerivative(dof_name, 1, *this->diffusion_rate);
diffusion_model/diffusion_model.cc:    if (this->method == _explicit_consistent_mass) {
diffusion_model/diffusion_model.cc:  AKANTU_DEBUG_ASSERT(this->getDOFManager().hasMatrix("K"),
diffusion_model/diffusion_model.cc:  this->getDOFManager().zeroMatrix("K");
diffusion_model/diffusion_model.cc:  this->internal_flow->zero();
diffusion_model/diffusion_model.cc:  this->synchronize(SynchronizationTag::_diffusion);
diffusion_model/diffusion_model.cc:  this->mesh.getDumper(id).setTimeStep(time_step);
diffusion_model/diffusion_model.cc:  if (!this->getDOFManager().hasLumpedMatrix("M")) {
diffusion_model/diffusion_model.cc:    this->getDOFManager().getNewLumpedMatrix("M");
diffusion_model/diffusion_model.cc:  this->getDOFManager().zeroLumpedMatrix("M");
diffusion_model/diffusion_model.cc:      fem.assembleFieldLumped(compute_rho, "M", dof_name, this->getDOFManager(),
diffusion_model/diffusion_model.cc:  this->getDOFManager().zeroMatrix("M");
diffusion_model/diffusion_model.cc:    fem.assembleFieldMatrix(rho_functor, "M", dof_name, this->getDOFManager(),
diffusion_model/diffusion_model.cc:  auto time_step = this->getTimeStep();
diffusion_model/diffusion_model.cc:      this->getConstitutiveLawLocalNumbering()(element);
diffusion_model/diffusion_model.cc:  return this->getConstitutiveLaw(element).getEnergy(energy_id,
diffusion_model/diffusion_model.cc:        mesh.getConnectivities(), group_name, this->spatial_dimension,
diffusion_model/diffusion_model.cc:  bool is_internal = this->isInternal(field_name, element_kind);
diffusion_model/diffusion_model.cc:        this->getInternalDataPerElem(field_name, element_kind);
diffusion_model/diffusion_model.cc:    auto & internal_flat = this->flattenInternal(field_name, element_kind);
solid_mechanics/solid_mechanics_model.cc:  this->initDOFManager(dof_manager);
solid_mechanics/solid_mechanics_model.cc:  this->registerFEEngineObject<MyFEEngineType>("SolidMechanicsFEEngine", mesh,
solid_mechanics/solid_mechanics_model.cc:  this->mesh.registerDumper<DumperParaview>("solid_mechanics_model", id, true);
solid_mechanics/solid_mechanics_model.cc:  this->mesh.addDumpMesh(mesh, Model::spatial_dimension, _not_ghost,
solid_mechanics/solid_mechanics_model.cc:  if (this->mesh.isDistributed()) {
solid_mechanics/solid_mechanics_model.cc:    auto & synchronizer = this->mesh.getElementSynchronizer();
solid_mechanics/solid_mechanics_model.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_smm_mass);
solid_mechanics/solid_mechanics_model.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_smm_stress);
solid_mechanics/solid_mechanics_model.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_smm_gradu);
solid_mechanics/solid_mechanics_model.cc:    this->registerSynchronizer(synchronizer, SynchronizationTag::_for_dump);
solid_mechanics/solid_mechanics_model.cc:  this->parser_type = ParserType::_material;
solid_mechanics/solid_mechanics_model.cc:  this->mesh.getDumper().setTimeStep(time_step);
solid_mechanics/solid_mechanics_model.cc:  // if (not this->parser.getLastParsedFile().empty()) {
solid_mechanics/solid_mechanics_model.cc:  //   this->instantiateMaterials();
solid_mechanics/solid_mechanics_model.cc:  //   this->initConstitutiveLaws();
solid_mechanics/solid_mechanics_model.cc:  this->initBC(*this, *displacement, *displacement_increment, *external_force);
solid_mechanics/solid_mechanics_model.cc:    if (this->method == _explicit_consistent_mass) {
solid_mechanics/solid_mechanics_model.cc:  auto & dof_manager = this->getDOFManager();
solid_mechanics/solid_mechanics_model.cc:  this->allocNodalField(this->displacement, spatial_dimension, "displacement");
solid_mechanics/solid_mechanics_model.cc:  this->allocNodalField(this->previous_displacement, spatial_dimension,
solid_mechanics/solid_mechanics_model.cc:  this->allocNodalField(this->displacement_increment, spatial_dimension,
solid_mechanics/solid_mechanics_model.cc:  this->allocNodalField(this->internal_force, spatial_dimension,
solid_mechanics/solid_mechanics_model.cc:  this->allocNodalField(this->external_force, spatial_dimension,
solid_mechanics/solid_mechanics_model.cc:  this->allocNodalField(this->blocked_dofs, spatial_dimension, "blocked_dofs");
solid_mechanics/solid_mechanics_model.cc:  this->allocNodalField(this->current_position, spatial_dimension,
solid_mechanics/solid_mechanics_model.cc:  this->current_position->copy(this->mesh.getNodes());
solid_mechanics/solid_mechanics_model.cc:    dof_manager.registerDOFs("displacement", *this->displacement, _dst_nodal);
solid_mechanics/solid_mechanics_model.cc:    dof_manager.registerBlockedDOFs("displacement", *this->blocked_dofs);
solid_mechanics/solid_mechanics_model.cc:                                      *this->displacement_increment);
solid_mechanics/solid_mechanics_model.cc:                                     *this->previous_displacement);
solid_mechanics/solid_mechanics_model.cc:    this->allocNodalField(this->velocity, spatial_dimension, "velocity");
solid_mechanics/solid_mechanics_model.cc:    this->allocNodalField(this->acceleration, spatial_dimension,
solid_mechanics/solid_mechanics_model.cc:      dof_manager.registerDOFsDerivative("displacement", 1, *this->velocity);
solid_mechanics/solid_mechanics_model.cc:                                         *this->acceleration);
solid_mechanics/solid_mechanics_model.cc:  this->assembleInternalForces();
solid_mechanics/solid_mechanics_model.cc:  this->getDOFManager().assembleToResidual("displacement",
solid_mechanics/solid_mechanics_model.cc:                                           *this->external_force, 1);
solid_mechanics/solid_mechanics_model.cc:  this->getDOFManager().assembleToResidual("displacement",
solid_mechanics/solid_mechanics_model.cc:                                           *this->internal_force, 1);
solid_mechanics/solid_mechanics_model.cc:    this->getDOFManager().assembleToResidual("displacement",
solid_mechanics/solid_mechanics_model.cc:                                             *this->external_force, 1);
solid_mechanics/solid_mechanics_model.cc:    this->assembleInternalForces();
solid_mechanics/solid_mechanics_model.cc:    this->getDOFManager().assembleToResidual("displacement",
solid_mechanics/solid_mechanics_model.cc:                                             *this->internal_force, 1);
solid_mechanics/solid_mechanics_model.cc:    this->assembleStiffnessMatrix();
solid_mechanics/solid_mechanics_model.cc:    this->assembleMass();
solid_mechanics/solid_mechanics_model.cc:    this->assembleMassLumped();
solid_mechanics/solid_mechanics_model.cc:  this->internal_force->zero();
solid_mechanics/solid_mechanics_model.cc:  if (this->isNonLocal()) {
solid_mechanics/solid_mechanics_model.cc:    this->getNonLocalManager().computeAllNonLocalContribution();
solid_mechanics/solid_mechanics_model.cc:  this->asynchronousSynchronize(SynchronizationTag::_smm_stress);
solid_mechanics/solid_mechanics_model.cc:  this->waitEndSynchronize(SynchronizationTag::_smm_stress);
solid_mechanics/solid_mechanics_model.cc:  if (not this->getDOFManager().hasMatrix("K")) {
solid_mechanics/solid_mechanics_model.cc:    this->getDOFManager().getNewMatrix("K", this->getMatrixType("K"));
solid_mechanics/solid_mechanics_model.cc:    this->getDOFManager().getMatrix("K").zero();
solid_mechanics/solid_mechanics_model.cc:  if (this->current_position_release == this->displacement_release) {
solid_mechanics/solid_mechanics_model.cc:  this->current_position->copy(this->mesh.getNodes());
solid_mechanics/solid_mechanics_model.cc:  for (auto && data : zip(make_view(*this->current_position, spatial_dimension),
solid_mechanics/solid_mechanics_model.cc:                          make_view(*this->displacement, spatial_dimension))) {
solid_mechanics/solid_mechanics_model.cc:  this->current_position_release = this->displacement_release;
solid_mechanics/solid_mechanics_model.cc:  this->updateCurrentPosition();
solid_mechanics/solid_mechanics_model.cc:  return *this->current_position;
solid_mechanics/solid_mechanics_model.cc:  this->updateCurrentPosition();
solid_mechanics/solid_mechanics_model.cc:    auto mat_indexes = this->getConstitutiveLawByElement(type, ghost_type);
solid_mechanics/solid_mechanics_model.cc:    auto mat_loc_num = this->getConstitutiveLawLocalNumbering(type, ghost_type);
solid_mechanics/solid_mechanics_model.cc:      auto el_c = this->getMaterial(mat_idx).getCelerity(elem);
solid_mechanics/solid_mechanics_model.cc:  if (this->getDOFManager().hasLumpedMatrix("M")) {
solid_mechanics/solid_mechanics_model.cc:    this->assembleLumpedMatrix("M");
solid_mechanics/solid_mechanics_model.cc:    auto m_it = this->mass->begin(Model::spatial_dimension);
solid_mechanics/solid_mechanics_model.cc:    auto m_end = this->mass->end(Model::spatial_dimension);
solid_mechanics/solid_mechanics_model.cc:    auto v_it = this->velocity->begin(Model::spatial_dimension);
solid_mechanics/solid_mechanics_model.cc:  } else if (this->getDOFManager().hasMatrix("M")) {
solid_mechanics/solid_mechanics_model.cc:    this->assembleMatrix("M");
solid_mechanics/solid_mechanics_model.cc:    this->getDOFManager().assembleMatMulVectToArray("displacement", "M",
solid_mechanics/solid_mechanics_model.cc:                                                    *this->velocity, Mv);
solid_mechanics/solid_mechanics_model.cc:                            make_view(*this->velocity, spatial_dimension))) {
solid_mechanics/solid_mechanics_model.cc:  if (this->method == _static) {
solid_mechanics/solid_mechanics_model.cc:    incrs_or_velos = this->displacement_increment.get();
solid_mechanics/solid_mechanics_model.cc:    incrs_or_velos = this->velocity.get();
solid_mechanics/solid_mechanics_model.cc:  auto nb_nodes = this->mesh.getNbNodes();
solid_mechanics/solid_mechanics_model.cc:    auto is_local_node = this->mesh.isLocalOrMasterNode(n);
solid_mechanics/solid_mechanics_model.cc:    // bool is_not_pbc_slave_node = !this->isPBCSlaveNode(n);
solid_mechanics/solid_mechanics_model.cc:  if (this->method != _static) {
solid_mechanics/solid_mechanics_model.cc:    work *= this->getTimeStep();
solid_mechanics/solid_mechanics_model.cc:  mat_element.element = this->getConstitutiveLawLocalNumbering()(element);
solid_mechanics/solid_mechanics_model.cc:      this->getConstitutiveLaw(element).getEnergy(energy_id, mat_element);
solid_mechanics/solid_mechanics_model.cc:  this->for_each_constitutive_law(
solid_mechanics/solid_mechanics_model.cc:  this->registerNewConstitutiveLaw(mat_name, mat_type, opt_param);
solid_mechanics/material_inline_impl.hh:    return (this->isFiniteDeformation() ? 3 : 1) * spatial_dimension *
solid_mechanics/material_inline_impl.hh:           this->getModel().getNbIntegrationPoints(elements);
solid_mechanics/material_inline_impl.hh:           this->getModel().getNbIntegrationPoints(elements);
solid_mechanics/material_inline_impl.hh:    if (this->isFiniteDeformation()) {
solid_mechanics/material_inline_impl.hh:    if (this->isFiniteDeformation()) {
common/dof_manager/dof_manager_petsc.cc:  this->mpi_communicator = mpi_comm;
common/dof_manager/dof_manager_petsc.cc:  this->mpi_communicator = PETSC_COMM_SELF;
common/dof_manager/dof_manager_petsc.cc:    auto & dof_data = this->getDOFDataTyped<DOFDataPETSc>(dof_id);
common/dof_manager/dof_manager_petsc.cc:    auto & A = this->getMatrix(mat.first);
common/dof_manager/dof_manager_petsc.cc:  return this->registerNonLinearSolver<NonLinearSolverPETSc>(*this, id, type);
common/dof_manager/dof_manager_petsc.cc:  return this->registerTimeStepSolver<TimeStepSolverDefault>(
common/dof_manager/dof_manager_petsc.cc:  return this->registerSparseMatrix<SparseMatrixPETSc>(*this, id, matrix_type);
common/dof_manager/dof_manager_petsc.cc:  return this->registerSparseMatrix<SparseMatrixPETSc>(id, matrix_to_copy_id);
common/dof_manager/dof_manager_petsc.cc:  return this->registerLumpedMatrix<SolverVectorPETSc>(*this, id);
common/dof_manager/dof_manager_petsc.cc:  return aka::as_type<SolverVectorPETSc>(*this->solution);
common/dof_manager/dof_manager_petsc.cc:  return aka::as_type<SolverVectorPETSc>(*this->solution);
common/dof_manager/dof_manager_petsc.cc:  return aka::as_type<SolverVectorPETSc>(*this->residual);
common/dof_manager/dof_manager_petsc.cc:  return aka::as_type<SolverVectorPETSc>(*this->residual);
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:  this->setFallback(
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:  this->setFallbackCohesiveValue(getDefaultCohesiveMaterial(model));
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:    if (this->getFallbackCohesiveValue() == -1) {
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:      this->setFallbackCohesiveValue(getDefaultCohesiveMaterial(this->model));
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:      return this->getFallbackCohesiveValue();
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:      return this->getFallbackCohesiveValue();
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:  this->setFallback(std::make_shared<MeshDataMaterialSelector<std::string>>(
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:      std::string material_name = this->material_index(facet);
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:      return this->model.getMaterialIndex(material_name);
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:  this->setFallback(std::make_shared<DefaultMaterialCohesiveSelector>(model));
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:  this->getFallbackSelector()->setFallback(
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:          this->mesh_data_id, model));
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:    auto id1 = this->mesh.getData<std::string>(mesh_data_id, el1);
solid_mechanics/solid_mechanics_model_cohesive/material_selector_cohesive.cc:      id2 = this->mesh.getData<std::string>(mesh_data_id, el2);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_parallel.cc:  auto & fe_engine = this->getFEEngine("FacetsFEEngine");
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_parallel.cc:  const auto & fe_engine = this->getFEEngine("FacetsFEEngine");
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_parallel.cc:        buffer << this->getConstitutiveLawByElement()(element);
solid_mechanics/materials/material_elastic.cc:  this->registerParam("lambda", lambda, _pat_readable,
solid_mechanics/materials/material_elastic.cc:  this->registerParam("mu", mu, _pat_readable, "Second Lamé coefficient");
solid_mechanics/materials/material_elastic.cc:  this->registerParam("kapa", kpa, _pat_readable, "Bulk coefficient");
solid_mechanics/materials/material_elastic.cc:    this->nu = 0.;
solid_mechanics/materials/material_elastic.cc:  this->updateInternalParameters();
solid_mechanics/materials/material_elastic.cc:  this->lambda = this->nu * this->E / ((1 + this->nu) * (1 - 2 * this->nu));
solid_mechanics/materials/material_elastic.cc:  this->mu = this->E / (2 * (1 + this->nu));
solid_mechanics/materials/material_elastic.cc:  this->kpa = this->lambda + 2. / 3. * this->mu;
solid_mechanics/materials/material_elastic.cc:  this->was_stiffness_assembled = false;
solid_mechanics/materials/material_elastic.cc:  this->lambda = this->nu * this->E / ((1 + this->nu) * (1 - 2 * this->nu));
solid_mechanics/materials/material_elastic.cc:  this->mu = this->E / (2 * (1 + this->nu));
solid_mechanics/materials/material_elastic.cc:  if (this->plane_stress) {
solid_mechanics/materials/material_elastic.cc:    this->lambda = this->nu * this->E / ((1 + this->nu) * (1 - this->nu));
solid_mechanics/materials/material_elastic.cc:  this->kpa = this->lambda + 2. / 3. * this->mu;
solid_mechanics/materials/material_elastic.cc:  this->was_stiffness_assembled = false;
solid_mechanics/materials/material_elastic.cc:  if (not this->finite_deformation) {
solid_mechanics/materials/material_elastic.cc:      this->computeStressOnQuad(args);
solid_mechanics/materials/material_elastic.cc:      auto && E = this->template gradUToE<dim>(args["grad_u"_n]);
solid_mechanics/materials/material_elastic.cc:      this->computeStressOnQuad(tuple::replace(args, "grad_u"_n = E));
solid_mechanics/materials/material_elastic.cc:    this->computeTangentModuliOnQuad(args);
solid_mechanics/materials/material_elastic.cc:  this->was_stiffness_assembled = true;
solid_mechanics/materials/material_elastic.cc:  return sqrt((lambda + 2 * mu) / this->rho);
solid_mechanics/materials/material_elastic.cc:  return sqrt(mu / this->rho);
solid_mechanics/materials/material_elastic.cc:  if (not this->finite_deformation) {
solid_mechanics/materials/material_elastic.cc:         zip(arguments, this->potential_energy(el_type, _not_ghost))) {
solid_mechanics/materials/material_elastic.cc:      this->computePotentialEnergyOnQuad(args, epot);
solid_mechanics/materials/material_elastic.cc:         zip(arguments, this->potential_energy(el_type, _not_ghost))) {
solid_mechanics/materials/material_elastic.cc:      auto && E = this->template gradUToE<dim>(args["grad_u"_n]);
solid_mechanics/materials/material_elastic.cc:      this->computePotentialEnergyOnQuad(tuple::replace(args, "grad_u"_n = E),
solid_mechanics/materials/material_elastic.cc:  auto gradu_view = make_view<dim, dim>(this->gradu(type));
solid_mechanics/materials/material_elastic.cc:  auto stress_view = make_view<dim, dim>(this->stress(type));
solid_mechanics/materials/material_elastic.cc:  if (this->finite_deformation) {
solid_mechanics/materials/material_elastic.cc:    stress_view = make_view<dim, dim>((*this->piola_kirchhoff_2)(type));
solid_mechanics/materials/material_elastic.cc:  auto nb_quadrature_points = this->getFEEngine().getNbIntegrationPoints(type);
solid_mechanics/materials/material_elastic.cc:  if (this->finite_deformation) {
solid_mechanics/materials/material_elastic.cc:      auto E = this->template gradUToE<dim>(data["grad_u"_n]);
solid_mechanics/materials/material_elastic.cc:      this->computePotentialEnergyOnQuad(tuple::replace(data, "grad_u"_n = E),
solid_mechanics/materials/material_elastic.cc:      this->computePotentialEnergyOnQuad(data, data["Epot"_n]);
solid_mechanics/materials/material_elastic.cc:  return std::sqrt(this->E / this->rho);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->registerParam("area", area, _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->registerParam("pre_stress", pre_stress, _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->element_filter.initialize(this->emodel.getInterfaceMesh(),
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  gradu_embedded = this->registerInternal("gradu_embedded", dim * dim,
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:      this->registerInternal("pre_stress", 1, "EmbeddedInterfaceFEEngine");
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->initFilters();
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->allocBackgroundShapeDerivatives();
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->initBackgroundShapeDerivatives();
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->initDirectingCosines();
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:                                "bg_" + shaped_id, this->name),
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:          std::make_unique<ElementTypeMapArray<Idx>>(shaped_id, this->name),
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  auto & elem_filter = this->element_filter(interface_type, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:      for (auto type : filter.elementTypes(this->spatial_dimension)) {
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:                               this->ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:      return array_size_per_bg_type(bgtype, this->ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:          std::make_unique<ElementTypeMapArray<Real>>(shaped_id, this->name),
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:       this->element_filter.elementTypes(this->spatial_dimension)) {
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:                                        this->element_filter(interface_type));
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  directing_cosines = this->registerInternal("directing_cosines", voigt_size,
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:    this->assembleInternalForces(type, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:    this->computeStress(type, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  auto & stress = this->stress(type, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  auto & sigma_p = this->pre_stress(type, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  const auto & elem_filter = this->element_filter(interface_type, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:           this->stress(interface_type, ghost_type),
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  Array<Real> node_coordinates(this->element_filter(type, ghost_type).size(),
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->emodel.getFEEngine().template extractNodalToElementField<Real>(
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:      ghost_type, this->element_filter(type, ghost_type));
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  Array<Idx> & elem_filter = this->element_filter(interface_type, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:  this->computeTangentModuli(interface_type, tangent_moduli, ghost_type);
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:    this->computePotentialEnergyByElements();
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:         this->element_filter.elementTypes(this->spatial_dimension)) {
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:          this->potential_energy(type, _not_ghost), type, _not_ghost,
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:          this->element_filter(type, _not_ghost));
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:             this->gradu(interface_type, ghost_type),
solid_mechanics/materials/material_embedded/material_reinforcement_tmpl.hh:             make_view(this->directing_cosines(interface_type, ghost_type),
solid_mechanics/materials/material_damage/material_anisotropic_damage.hh:        "damage"_n = make_view<dim, dim>(this->damage(el_type, ghost_type)),
solid_mechanics/materials/material_damage/material_anisotropic_damage.hh:            make_view<dim, dim>(this->elastic_stress(el_type, ghost_type)),
solid_mechanics/materials/material_damage/material_anisotropic_damage.hh:        "epsilon_hat"_n = this->equivalent_strain(el_type, ghost_type),
solid_mechanics/materials/material_damage/material_anisotropic_damage.hh:        "TrD"_n = this->trace_damage(el_type, ghost_type),
solid_mechanics/materials/material_damage/material_anisotropic_damage.hh:        "TrD_n_1"_n = this->trace_damage.previous(el_type, ghost_type),
solid_mechanics/materials/material_damage/material_phasefield.hh:                          this->effective_damage(el_type, ghost_type)));
solid_mechanics/materials/material_damage/material_phasefield.hh:            make_view(this->effective_damage(el_type, ghost_type)));
solid_mechanics/materials/material_damage/material_marigo.cc:    : MaterialDamage<dim>(model, id), Y(this->registerInternal("Y", 1)),
solid_mechanics/materials/material_damage/material_marigo.cc:      Yd(this->template registerInternal<Real, DefaultRandomInternalField>("Yd",
solid_mechanics/materials/material_damage/material_marigo.cc:  this->registerParam("Sd", Sd, Real(5000.), _pat_parsable | _pat_modifiable);
solid_mechanics/materials/material_damage/material_marigo.cc:  this->registerParam("epsilon_c", epsilon_c, Real(0.), _pat_parsable,
solid_mechanics/materials/material_damage/material_marigo.cc:  this->registerParam("Yc limit", yc_limit, false, _pat_internal,
solid_mechanics/materials/material_damage/material_marigo.cc:  this->registerParam("damage_in_y", damage_in_y, false, _pat_parsable,
solid_mechanics/materials/material_damage/material_marigo.cc:  this->registerParam("Yd", Yd, _pat_parsable, "Damaging energy threshold");
solid_mechanics/materials/material_damage/material_marigo.cc:  Yc = epsilon_c * this->E * epsilon_c / 2.;
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.hh:  //                         this->effective_damage(el_type, ghost_type)));
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.hh:  //           make_view(this->effective_damage(el_type, ghost_type)));
solid_mechanics/materials/material_damage/material_marigo.hh:                      "Yd"_n = this->Yd(el_type, ghost_type),
solid_mechanics/materials/material_damage/material_marigo.hh:                      "Y"_n = this->Y(el_type, ghost_type));
solid_mechanics/materials/material_damage/material_damage_non_local.hh:    for (auto type : this->getElementFilter().elementTypes(dim, ghost_type)) {
solid_mechanics/materials/material_damage/material_damage_non_local.hh:      auto & elem_filter = this->getElementFilter(type, ghost_type);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:  this->registerParam("eta", eta, Real(0.), _pat_parsable, "eta");
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:  this->registerParam("is_isotropic", is_isotropic, false,
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:  this->damage.initialize(0);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:  if (not this->finite_deformation) {
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:      this->computeStressOnQuad(args);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:      auto && E = this->template gradUToE<dim>(args["grad_u"_n]);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:      this->computeStressOnQuad(tuple::replace(args, "grad_u"_n = E));
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:  this->dev_dim = 2;
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:  if (!this->plane_stress) {
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:    this->dev_dim = 3;
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:  if (not this->finite_deformation) {
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:      this->computeTangentModuliOnQuad(args);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:      auto && E = this->template gradUToE<dim>(args["grad_u"_n]);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic.cc:      this->computeTangentModuliOnQuad(tuple::replace(args, "grad_u"_n = E));
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:    : Parent<dim>(model, id), damage(this->registerInternal("damage", 1)),
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:      dissipated_energy(this->registerInternal("damage dissipated energy", 1)),
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:      int_sigma(this->registerInternal("integral of sigma", 1)) {
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:  this->computePotentialEnergy(el_type);
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:       zip(getArguments(el_type), this->potential_energy(el_type),
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:           this->dissipated_energy(el_type), this->int_sigma(el_type))) {
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:  for (auto && type : this->getElementFilter().elementTypes(dim, _not_ghost)) {
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:    de += this->getFEEngine().integrate(
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:        this->dissipated_energy(type, _not_ghost), type, _not_ghost,
solid_mechanics/materials/material_damage/material_damage_tmpl.hh:        this->getElementFilter(type, _not_ghost));
solid_mechanics/materials/material_damage/material_mazars.hh:        "K0"_n = this->K0(el_type, ghost_type),
solid_mechanics/materials/material_damage/material_mazars.hh:            broadcast(this->Ehat, this->damage(el_type, ghost_type).size()));
solid_mechanics/materials/material_damage/material_marigo_non_local.hh:                       "Y"_n = this->Ynl(el_type, ghost_type));
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:    : parent(model, id), Ehat(this->registerInternal("Ehat", 1)),
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:      non_local_variable(this->registerInternal("non_local_variable", 1)) {
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:  this->is_non_local = true;
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:  this->registerParam("average_on_damage", this->damage_in_compute_stress,
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:  if (this->damage_in_compute_stress) {
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:    local = this->damage.getName();
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:    local = this->Ehat.getName();
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:  this->getModel().getNonLocalManager().registerNonLocalVariable(
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:  this->getModel()
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:      .getNeighborhood(this->name)
solid_mechanics/materials/material_damage/material_mazars_non_local_tmpl.hh:  if (this->damage_in_compute_stress) {
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:      K0(this->template registerInternal<Real, DefaultRandomInternalField>("K0",
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  this->registerParam("K0", this->K0, _pat_parsable, "K0");
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  this->registerParam("At", this->At, Real(0.8), _pat_parsable, "At");
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  this->registerParam("Ac", this->Ac, Real(1.4), _pat_parsable, "Ac");
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  this->registerParam("Bc", this->Bc, Real(1900.), _pat_parsable, "Bc");
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  this->registerParam("Bt", this->Bt, Real(12000.), _pat_parsable, "Bt");
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  this->registerParam("beta", this->beta, Real(1.06), _pat_parsable, "beta");
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  if (not this->is_non_local) {
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  auto Cdiag = this->E * (1 - this->nu) / ((1 + this->nu) * (1 - 2 * this->nu));
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:                   this->lambda * (epsilon_princ(1) + epsilon_princ(2));
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:                   this->lambda * (epsilon_princ(0) + epsilon_princ(2));
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:                   this->lambda * (epsilon_princ(1) + epsilon_princ(0));
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:  auto trace_p = this->nu / this->E * (sigma_p(0) + sigma_p(1) + sigma_p(2));
solid_mechanics/materials/material_damage/material_mazars_inline_impl.hh:    auto epsilon_t = (1 + this->nu) / this->E * sigma_p(i) - trace_p;
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:    MeshSegmentIntersector<dim, type> intersector(this->mesh, interface_mesh); \
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:  const Int dim = this->mesh.getSpatialDimension();
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:        this->primitive_mesh.getData<std::string>("physical_names",
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:    auto segment = this->createSegment(el_connectivity);
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:  for (auto type : this->mesh.elementTypes(dim, _not_ghost)) {
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:          MeshSegmentIntersector<dim, type> intersector(this->mesh,
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:  const auto & nodes = this->primitive_mesh.getNodes();
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:  if (this->mesh.getSpatialDimension() == 2) {
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_intersector.cc:  } else if (this->mesh.getSpatialDimension() == 3) {
solid_mechanics/materials/material_damage/material_marigo_inline_impl.hh:  if (this->damage_in_y) {
solid_mechanics/materials/material_damage/material_marigo_inline_impl.hh:  if (this->yc_limit) {
solid_mechanics/materials/material_damage/material_marigo_inline_impl.hh:    Y = std::min(Y, this->Yc);
solid_mechanics/materials/material_damage/material_marigo_inline_impl.hh:  if (not this->is_non_local) {
solid_mechanics/materials/material_damage/material_marigo_inline_impl.hh:    size += sizeof(Real) * this->getModel().getNbIntegrationPoints(elements);
solid_mechanics/materials/material_damage/material_marigo_inline_impl.hh:    this->packInternalFieldHelper(Yd, buffer, elements);
solid_mechanics/materials/material_damage/material_marigo_inline_impl.hh:    this->unpackInternalFieldHelper(Yd, buffer, elements);
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:      damage(this->registerInternal("damage", dim * dim)),
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:      elastic_stress(this->registerInternal("elastic_stress", dim * dim)),
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:      equivalent_strain(this->registerInternal("equivalent_strain", 1)),
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:      trace_damage(this->registerInternal("trace_damage", 1)) {
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:  this->registerParam("Dc", Dc, _pat_parsable, "Critical damage");
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:  this->trace_damage.initializeHistory();
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:    epsilon = this->template gradUToEpsilon<dim>(grad_u);
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:        auto kpa = this->kpa;
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:        auto lambda = this->lambda;
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:        this->E = 9 * kpa * (kpa - lambda) / (3 * kpa - lambda);
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:        this->nu = lambda / (3 * kpa - lambda);
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:        this->updateInternalParameters();
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:          if (x > this->Dc) {
solid_mechanics/materials/material_damage/material_anisotropic_damage_tmpl.hh:            return this->Dc;
solid_mechanics/materials/material_damage/material_phasefield_inline_impl.hh:  Real kappa = this->lambda + 2. / Real(dim) * this->mu;
solid_mechanics/materials/material_damage/material_phasefield_inline_impl.hh:                            this->mu * strain_dev.doubleDot(strain_dev);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic_inline_impl.hh:  Real kappa = this->lambda + 2. / Real(dev_dim) * this->mu;
solid_mechanics/materials/material_damage/material_phasefield_anisotropic_inline_impl.hh:                    2. * this->mu * strain_dev;
solid_mechanics/materials/material_damage/material_phasefield_anisotropic_inline_impl.hh:    tangent(0, 0) = g_d_hyd * this->E;
solid_mechanics/materials/material_damage/material_phasefield_anisotropic_inline_impl.hh:  Real kappa = this->lambda + 2. / Real(dim) * this->mu;
solid_mechanics/materials/material_damage/material_phasefield_anisotropic_inline_impl.hh:  auto Miiii = g_d_hyd * kappa + g_d * 2. * this->mu * (1. - 1. / Real(dev_dim));
solid_mechanics/materials/material_damage/material_phasefield_anisotropic_inline_impl.hh:  [[maybe_unused]] auto Miijj = g_d_hyd * kappa - g_d * 2. * this->mu / Real(dev_dim);
solid_mechanics/materials/material_damage/material_phasefield_anisotropic_inline_impl.hh:  [[maybe_unused]] auto Mijij = g_d * this->mu;
solid_mechanics/materials/material_damage/material_phasefield.cc:      effective_damage(this->registerInternal("effective_damage", 1)) {
solid_mechanics/materials/material_damage/material_phasefield.cc:  this->registerParam("eta", eta, Real(0.), _pat_parsable, "eta");
solid_mechanics/materials/material_damage/material_phasefield.cc:  this->registerParam("is_hybrid", is_hybrid, false,
solid_mechanics/materials/material_damage/material_phasefield.cc:  if (this->is_hybrid) {
solid_mechanics/materials/material_damage/material_phasefield.cc:  if (this->is_hybrid) {
solid_mechanics/materials/weight_functions/remove_damaged_with_damage_rate_weight_function_inline_impl.hh:  this->damage_with_damage_rate =
solid_mechanics/materials/weight_functions/remove_damaged_with_damage_rate_weight_function_inline_impl.hh:      &(this->manager.registerWeightFunctionInternal("damage-rate"));
solid_mechanics/materials/weight_functions/remove_damaged_with_damage_rate_weight_function_inline_impl.hh:      (*this->damage_with_damage_rate)(q2.type, q2.ghost_type);
solid_mechanics/materials/weight_functions/remove_damaged_with_damage_rate_weight_function_inline_impl.hh:    Real alpha = std::max(0., 1. - pow((r * r / this->R2), alphaexp));
solid_mechanics/materials/material_damage/material_damage.hh:                      "damage"_n = this->damage(el_type, ghost_type),
solid_mechanics/materials/material_damage/material_damage.hh:                          this->damage.previous(el_type, ghost_type));
solid_mechanics/materials/material_damage/material_damage.hh:        "damage"_n = this->damage(el_type, ghost_type),
solid_mechanics/materials/material_damage/material_damage.hh:        "previous_damage"_n = this->damage.previous(el_type, ghost_type));
solid_mechanics/materials/material_damage/material_mazars_non_local.hh:                       "Ehat"_n = make_view(this->Ehat(el_type, ghost_type)));
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:      Ynl(this->template registerInternal<Real>("Y non local", 1)) {
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:  this->is_non_local = true;
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:  this->getModel().getNonLocalManager().registerNonLocalVariable(
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:      this->Y.getName(), Ynl.getName(), 1);
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:  this->getModel()
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:      .getNeighborhood(this->name)
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:  auto && arguments = this->getArguments(el_type, ghost_type);
solid_mechanics/materials/material_damage/material_marigo_non_local.cc:    this->computeDamageAndStressOnQuad(data);
solid_mechanics/materials/weight_functions/remove_damaged_weight_function_inline_impl.hh:  auto & dam_array = (*this->damage)(q2.type, q2.ghost_type);
solid_mechanics/materials/weight_functions/remove_damaged_weight_function_inline_impl.hh:    Real alpha = std::max(0., 1. - r * r / this->R2);
solid_mechanics/materials/weight_functions/remove_damaged_weight_function_inline_impl.hh:  this->damage = &(this->manager.registerWeightFunctionInternal("damage"));
solid_mechanics/materials/weight_functions/remove_damaged_weight_function_inline_impl.hh:    return this->manager.getModel().getNbIntegrationPoints(elements) *
solid_mechanics/materials/weight_functions/remove_damaged_weight_function_inline_impl.hh:        *damage, buffer, elements, this->manager.getModel().getFEEngine());
solid_mechanics/materials/weight_functions/remove_damaged_weight_function_inline_impl.hh:        *damage, buffer, elements, this->manager.getModel().getFEEngine());
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_model.cc:  this->model_type = ModelType::_embedded_model;
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_model.cc:  this->setMaterialSelector(mat_sel_pointer);
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_model.cc:  this->mesh.registerDumper<DumperParaview>("reinforcement", id);
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_model.cc:  this->mesh.addDumpMeshToDumper("reinforcement", *interface_mesh, 1,
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_model.cc:        // this->material_local_numbering(element) = index;
solid_mechanics/solid_mechanics_model_embedded_interface/embedded_interface_model.cc:    field = this->createElementalField(field_id, group_name, padding_flag, 1,
solid_mechanics/materials/weight_functions/damaged_weight_function_inline_impl.hh:  Array<Real> & dam_array = (*this->damage)(q2.type, q2.ghost_type);
solid_mechanics/materials/weight_functions/damaged_weight_function_inline_impl.hh:  Real Radius_init = this->R2;
solid_mechanics/materials/weight_functions/damaged_weight_function_inline_impl.hh:  this->damage = &(this->manager.registerWeightFunctionInternal("damage"));
solid_mechanics/materials/weight_functions/damaged_weight_function.hh:    this->init();
solid_mechanics/materials/weight_functions/remove_damaged_with_damage_rate_weight_function.hh:    this->registerParam<Real>("damage_limit",
solid_mechanics/materials/weight_functions/remove_damaged_with_damage_rate_weight_function.hh:                              this->damage_limit_with_damage_rate, 1,
solid_mechanics/materials/weight_functions/remove_damaged_with_damage_rate_weight_function.hh:    this->init();
solid_mechanics/materials/material_damage/material_von_mises_mazars_inline_impl.hh:  if (not this->is_non_local) {
solid_mechanics/materials/material_damage/material_von_mises_mazars_inline_impl.hh:    Cdiag = this->E * (1 - this->nu) / ((1 + this->nu) * (1 - 2 * this->nu));
solid_mechanics/materials/material_damage/material_von_mises_mazars_inline_impl.hh:                     this->lambda * (epsilon_princ(1) + epsilon_princ(2));
solid_mechanics/materials/material_damage/material_von_mises_mazars_inline_impl.hh:                     this->lambda * (epsilon_princ(0) + epsilon_princ(2));
solid_mechanics/materials/material_damage/material_von_mises_mazars_inline_impl.hh:                     this->lambda * (epsilon_princ(1) + epsilon_princ(0));
solid_mechanics/materials/material_damage/material_von_mises_mazars_inline_impl.hh:    Real trace_p = this->nu / this->E * (sigma_p(0) + sigma_p(1) + sigma_p(2));
solid_mechanics/materials/material_damage/material_von_mises_mazars_inline_impl.hh:      Real epsilon_t = (1 + this->nu) / this->E * sigma_p(i) - trace_p;
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->registerParam("E", E, Real(0.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->registerParam("nu", nu, Real(0.5), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->registerParam("lambda", lambda, _pat_readable,
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->registerParam("mu", mu, _pat_readable, "Second Lamé coefficient");
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->registerParam("kapa", kpa, _pat_readable, "Bulk coefficient");
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->finite_deformation = true;
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->updateInternalParameters();
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  this->updateInternalParameters();
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:       zip(make_view<2, 2>(this->gradu(el_type, ghost_type)),
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:           make_view<2, 2>((*this->piola_kirchhoff_2)(el_type, ghost_type)),
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:           make_view<2, 2>(this->stress(el_type, ghost_type)),
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:           make_view(this->third_axis_deformation(el_type, ghost_type)))) {
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  for (auto && args : this->getArguments(el_type, ghost_type)) {
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  AKANTU_DEBUG_ASSERT(this->plane_stress, "The third component of the strain "
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:       zip(arguments, this->potential_energy(el_type, _not_ghost))) {
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:    this->computePotentialEnergyOnQuad(args, epot);
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  return std::sqrt((this->lambda + 2 * this->mu) / this->rho);
solid_mechanics/materials/material_finite_deformation/material_neohookean.cc:  return std::sqrt(this->mu / this->rho);
solid_mechanics/materials/material_finite_deformation/material_neohookean_inline_impl.hh:    return (this->lambda / 2. *
solid_mechanics/materials/material_finite_deformation/material_neohookean_inline_impl.hh:                (std::log(x) + std::log(this->C(0, 0) * this->C(1, 1) -
solid_mechanics/materials/material_finite_deformation/material_neohookean_inline_impl.hh:                                        Math::pow<2>(this->C(0, 1)))) +
solid_mechanics/materials/material_finite_deformation/material_neohookean_inline_impl.hh:            this->mu * (x - 1.));
solid_mechanics/materials/material_finite_deformation/material_neohookean_inline_impl.hh:    return (this->lambda / (2. * x) + this->mu);
solid_mechanics/materials/material_finite_deformation/material_neohookean_inline_impl.hh:  C33 = nr.solve(C33_NR("Neohookean_plan_stress", this->lambda, this->mu, C),
solid_mechanics/materials/material_embedded/material_reinforcement.hh: *  -  this->spatial_dimension is always 1
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:    this->registerParam("Plane_Stress", plane_stress, false, _pat_parsmod,
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:    this->third_axis_deformation.setDefaultValue(1.);
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:    if (this->plane_stress) {
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:    if (this->plane_stress) {
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:      AKANTU_DEBUG_ASSERT(this->finite_deformation,
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:      for (auto && type : this->elementTypes(2, ghost_type)) {
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:        this->computeCauchyStressPlaneStress(type, ghost_type);
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:          this->registerInternal("third_axis_deformation", 1)) {
solid_mechanics/materials/plane_stress_toolbox_tmpl.hh:  this->initialize();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// // this->implicitPred();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     displacement_tmp->copy(*(this->displacement));
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     velocity_tmp->copy(*(this->velocity));
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     acceleration_tmp->copy(*(this->acceleration));
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //   this->updateResidual();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     this->assembleStiffnessMatrix();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     converged = this->testConvergence<criteria>(tolerance, error);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //       this->assembleStiffnessMatrix();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     this->implicitCorr();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     this->updateResidual();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     converged = this->testConvergence<criteria>(tolerance, error);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     displacement_tmp = this->displacement;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     this->displacement = tmp_swap;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     velocity_tmp = this->velocity;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     this->velocity = tmp_swap;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     acceleration_tmp = this->acceleration;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //     this->acceleration = tmp_swap;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //   this->displacement->copy(*displacement_tmp);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //   this->velocity->copy(*velocity_tmp);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive_inline_impl.hh:// //   this->acceleration->copy(*acceleration_tmp);
solid_mechanics/materials/material_elastic_linear_anisotropic_inline_impl.hh:  auto voigt_stress = this->C * voigt_strain;
solid_mechanics/materials/material_elastic_linear_anisotropic_inline_impl.hh:  args["tangent_moduli"_n] = this->C;
solid_mechanics/materials/material_elastic_linear_anisotropic_inline_impl.hh:  AKANTU_DEBUG_ASSERT(this->symmetric,
solid_mechanics/materials/material_thermal.hh:  sigma = -this->E / (1. - 2. * this->nu) * this->alpha * deltaT;
solid_mechanics/materials/material_thermal.hh:  sigma = -this->E * this->alpha * deltaT;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  tmp_material_selector->setFallback(this->getConstitutiveLawSelector());
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->setConstitutiveLawSelector(tmp_material_selector);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->mesh.registerDumper<DumperParaview>("cohesive elements", id);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->mesh.addDumpMeshToDumper("cohesive elements", mesh,
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  if (this->mesh.isDistributed()) {
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->cohesive_synchronizer = std::make_unique<ElementSynchronizer>(
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->cohesive_synchronizer->split(synchronizer, [](auto && el) {
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->registerSynchronizer(*cohesive_synchronizer,
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->registerSynchronizer(*cohesive_synchronizer,
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->registerSynchronizer(*cohesive_synchronizer,
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->inserter = std::make_unique<CohesiveElementInserter>(
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:      this->mesh, id + ":cohesive_element_inserter");
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->mesh.getDumper("cohesive elements").setTimeStep(time_step);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->is_extrinsic = smmc_options.is_extrinsic;
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:      this->registerSynchronizer(*facet_stress_synchronizer,
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  auto && [section, is_empty] = this->getParserSection();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  auto & material_selector = this->getConstitutiveLawSelector();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:            aka::as_type<MaterialCohesive>(this->getConstitutiveLaw(mat_index));
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->initAutomaticInsertion();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->insertIntrinsicElements();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->inserter->limitCheckFacets();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->updateFacetStressSynchronizer();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->resizeFacetStress();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->computeNormals();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->initStressInterpolation();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->inserter->limitCheckFacets();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->updateFacetStressSynchronizer();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->for_each_constitutive_law([&](auto && material) {
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->for_each_constitutive_law([&](auto && material) {
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  Mesh & mesh_facets = this->inserter->getMeshFacets();
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->getFEEngine("FacetsFEEngine")
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:        this->getFEEngine("FacetsFEEngine")
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    Array<Real> & tangents = this->tangents(facet_type);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->for_each_constitutive_law([&](auto && material) {
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->synchronize(SynchronizationTag::_smmc_facets_stress);
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->for_each_constitutive_law([&](auto && material) {
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:    this->for_each_constitutive_law([](auto && mat) {
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->facet_stress.initialize(getFEEngine("FacetsFEEngine"),
solid_mechanics/solid_mechanics_model_cohesive/solid_mechanics_model_cohesive.cc:  this->flattenAllRegisteredInternals(_ek_cohesive);
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  this->element_kind = _ek_cohesive;
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  this->internalInitialize(nb_component);
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  return this->registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  return this->registerInternal<Real, CohesiveRandomInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  this->spatial_dimension -= 1;
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  this->element_kind = _ek_regular;
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  this->internalInitialize(nb_component);
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  return this->registerInternal<Real, FacetInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field_tmpl.hh:  return this->registerInternal<Real, FacetRandomInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/cohesive_internal_field.hh:    return aka::as_type<FacetInternalField>(this->shared_from_this());
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:  this->registerParam("sigma_c", sigma_c, _pat_parsable | _pat_readable,
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:  this->registerParam("delta_c", delta_c, Real(0.),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:  this->getElementFilter().initialize(this->model->getMesh(),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:  if (this->model->getIsExtrinsic()) {
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:    this->getFacetFilter().initialize(this->model->getMeshFacets(),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:  if (this->use_previous_delta_max) {
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:    this->delta_max.initializeHistory();
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:  this->opening.initializeHistory();
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:  this->tractions.initializeHistory();
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:      this->model->getFEEngineClass<MyFEEngineCohesiveType>("CohesiveFEEngine");
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.cc:      this->model->getFEEngineClass<MyFEEngineCohesiveType>("CohesiveFEEngine");
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:        "normal"_n = make_view<dim>(this->normals(element_type, ghost_type)),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:        "opening"_n = make_view<dim>(this->opening(element_type, ghost_type)),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:            make_view<dim>(this->tractions(element_type, ghost_type)),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:            make_view<dim>(this->contact_opening(element_type, ghost_type)),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:            make_view<dim>(this->contact_tractions(element_type, ghost_type)),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:            make_view<dim>(this->opening.previous(element_type, ghost_type)),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:            make_view<dim>(this->tractions.previous(element_type, ghost_type)),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:        "delta_max"_n = this->delta_max(element_type, ghost_type),
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive.hh:        "damage"_n = this->damage(element_type, ghost_type));
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive_inline_impl.hh:           this->getModel().getNbIntegrationPoints(elements,
solid_mechanics/solid_mechanics_model_cohesive/materials/material_cohesive_inline_impl.hh:    return Int(sizeof(Real)) * this->getModel().getNbIntegrationPoints(
solid_mechanics/materials/weight_functions/stress_based_weight_function_inline_impl.hh:  // Real rho_lc_2 = std::max(this->R2 * rho_2, min_rho_lc*min_rho_lc);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->normal_opening_norm = norm;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->normal_opening = normal * this->normal_opening_norm;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->tangential_opening = opening - normal_opening;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->tangential_opening_norm = this->tangential_opening.norm();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  auto delta = this->tangential_opening_norm * this->tangential_opening_norm *
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:               this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  penetration = this->normal_opening_norm / delta_c < -Math::getTolerance();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  if (not this->contact_after_breaking and Math::are_float_equal(damage, 1.)) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:    contact_traction = this->normal_opening * this->penalty;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:    contact_opening = this->normal_opening;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:    this->normal_opening.zero();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:    delta += this->normal_opening_norm * this->normal_opening_norm;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:        (this->tangential_opening * this->beta2_kappa + this->normal_opening) *
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->normal_opening_norm = opening.dot(normal);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->normal_opening = normal * normal_opening_norm;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->tangential_opening = opening - normal_opening;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  this->tangential_opening_norm = tangential_opening.norm();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  auto delta = this->tangential_opening_norm * this->tangential_opening_norm *
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:               this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  if (not this->contact_after_breaking and Math::are_float_equal(damage, 1.)) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  Real sigma_c = this->sigma_c;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  auto && I = Eigen::Matrix<Real, dim, dim>::Identity() * this->beta2_kappa;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  auto && nn = (n_outer_n * (1. - this->beta2_kappa) + I) * t / delta;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  auto && mm = opening * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  auto && t_tilde = normal_opening * (1. - this->beta2_kappa2) + mm;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_inline_impl.hh:  auto && t_hat = normal_opening + this->beta2_kappa * tangential_opening;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_exponential.cc:  this->registerParam("beta", beta, Real(0.), _pat_parsable, "Beta parameter");
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_exponential.cc:  this->registerParam("exponential_penalty", exp_penalty, true, _pat_parsable,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_exponential.cc:  this->registerParam(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_exponential.cc:  // this->initInternalArray(delta_max, 1, _ek_cohesive);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:          this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:          this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:  this->registerParam("mu", mu_max, Real(0.), _pat_parsable | _pat_readable,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:  this->registerParam("penalty_for_friction", friction_penalty, Real(0.),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:  if (not this->penetration) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:  Real tau_max = mu * this->penalty * (std::abs(this->normal_opening_norm));
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:      std::abs(this->tangential_opening_norm - res_sliding_prev);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:  if ((this->tangential_opening_norm - res_sliding_prev) < 0.0) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:      tau * this->tangential_opening / this->tangential_opening_norm;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:    res_sliding = this->tangential_opening_norm;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:        this->tangential_opening_norm - (std::abs(tau) / friction_penalty);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:  if (not this->model->isDefaultSolverExplicit()) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:    this->delta_max(el_type, ghost_type)
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:        .copy(this->delta_max.previous(el_type, ghost_type));
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:    this->computeTangentTractionOnQuad(tangent, args);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:    if (not this->penetration) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:        mu * this->penalty * (std::abs(previous_normal_opening_norm));
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:    Real delta_sliding_norm = std::abs(this->tangential_opening_norm -
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_friction.cc:    Real tau = std::min(this->friction_penalty * delta_sliding_norm, tau_max);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.hh:        "sigma_c"_n = this->sigma_c_eff(element_type, ghost_type),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.hh:        "delta_c"_n = this->delta_c_eff(element_type, ghost_type),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.hh:            make_view<dim>(this->insertion_stress(element_type, ghost_type)));
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  this->registerParam("delta_0", delta_0, Real(0.),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  this->sigma_c_eff.setRandomDistribution(this->sigma_c.getRandomParameter());
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  this->delta_max.setDefaultValue(delta_0);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  this->insertion_stress.setDefaultValue(0);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  this->delta_max.reset();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  this->insertion_stress.reset();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  if (!Math::are_float_equal(this->volume_s, 0.)) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:    auto nb_quad_per_element = this->fem_cohesive.getNbIntegrationPoints(type);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:        make_view(this->sigma_c_eff(type), nb_quad_per_element).begin();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:        make_view(this->delta_c_eff(type), nb_quad_per_element).begin();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:      delta_c_vec(q) = 2 * this->G_c / sigma_c_vec(q);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  auto base_sigma_c = Real(this->sigma_c_eff);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  const auto & mesh_facets = this->model->getMeshFacets();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  const auto & fe_engine = this->model->getFEEngine();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:                    std::pow(this->volume_s / volume, 1. / this->m_s) +
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:  for (auto && data : zip(this->damage(el_type, ghost_type),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:                          this->delta_max(el_type, ghost_type),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_bilinear.cc:                          this->delta_c_eff(el_type, ghost_type))) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      delta_prec(this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      K_plus(this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      K_minus(this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      T_1d(this->template registerInternal<Real, CohesiveInternalField>("T_1d",
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:          this->template registerInternal<bool, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  this->registerParam("delta_f", delta_f, Real(-1.),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  this->registerParam("progressive_delta_f", progressive_delta_f, false,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  this->registerParam("count_switches", count_switches, false,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  this->registerParam(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:    delta_f = this->delta_c_eff;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  } else if (delta_f < this->delta_c_eff) {
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:    this->template registerInternal<Int, CohesiveInternalField>("switches", 1);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:    switches = this->template getSharedPtrInternal<Int, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:    this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:        this->template getSharedPtrInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      this->tractions(el_type, ghost_type).begin(spatial_dimension);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  auto opening_it = this->opening(el_type, ghost_type).begin(spatial_dimension);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      this->contact_tractions(el_type, ghost_type).begin(spatial_dimension);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      this->contact_opening(el_type, ghost_type).begin(spatial_dimension);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  auto normal_it = this->normals(el_type, ghost_type).begin(spatial_dimension);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      this->tractions(el_type, ghost_type).end(spatial_dimension);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  const Array<Real> & sigma_c_array = this->sigma_c_eff(el_type, ghost_type);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  Array<Real> & delta_max_array = this->delta_max(el_type, ghost_type);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  const Array<Real> & delta_c_array = this->delta_c_eff(el_type, ghost_type);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:  Array<Real> & damage_array = this->damage(el_type, ghost_type);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      this->insertion_stress(el_type, ghost_type).begin(spatial_dimension);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:        tangential_opening_norm * tangential_opening_norm * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:    if (not this->contact_after_breaking and
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:      *contact_traction_it *= this->penalty;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_fatigue.cc:        *traction_it *= this->beta2_kappa;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      delta_n_max(this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      delta_t_max(this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      damage_n(this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      damage_t(this->template registerInternal<Real, CohesiveInternalField>(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  this->registerParam(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto traction_it = this->tractions(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto traction_end = this->tractions(el_type, ghost_type).end(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto opening_it = this->opening(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      this->contact_tractions(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      this->contact_opening(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto normal_it = this->normals(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto sigma_c_it = this->sigma_c_eff(el_type, ghost_type).begin();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto delta_c_it = this->delta_c_eff(el_type, ghost_type).begin();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      this->insertion_stress(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:        tangential_opening_norm * tangential_opening_norm * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:        tangential_opening_norm * tangential_opening_norm * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:    if (not this->contact_after_breaking and
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      *contact_traction_it = normal_opening * this->penalty;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      shear_traction = tangential_opening * this->beta2_kappa * *sigma_c_it /
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto normal_it = this->normals(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto opening_it = this->opening(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto sigma_c_it = this->sigma_c_eff(el_type, ghost_type).begin();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:  auto delta_c_it = this->delta_c_eff(el_type, ghost_type).begin();
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      this->contact_opening(el_type, ghost_type).begin(dim);
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:        tangential_opening_norm * tangential_opening_norm * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:        tangential_opening_norm * tangential_opening_norm * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:    if (not this->contact_after_breaking and
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:      *tangent_it = n_outer_n * this->penalty;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:          normal_opening * (1. - this->beta2_kappa2) +
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:          *opening_it * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:    auto && Delta_tilde = normal_opening * (delta_c2_R2 - this->beta2_kappa2) +
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:                          *opening_it * this->beta2_kappa2;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear_uncoupled.cc:    auto && Delta_hat = tangential_opening * this->beta2_kappa;
solid_mechanics/materials/material_elastic_inline_impl.hh:  sigma(0, 0) = this->E * grad_u(0, 0) + sigma_th;
solid_mechanics/materials/material_elastic_inline_impl.hh:    tangent(0, 0) = this->E;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("beta", beta, Real(0.), _pat_parsable | _pat_readable,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("G_c", G_c, Real(0.), _pat_parsable | _pat_readable,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("penalty", penalty, Real(0.),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("volume_s", volume_s, Real(0.),
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("m_s", m_s, Real(1.), _pat_parsable | _pat_readable,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("kappa", kappa, Real(1.), _pat_parsable | _pat_readable,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam(
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("max_quad_stress_insertion", max_quad_stress_insertion,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->registerParam("recompute", recompute, false,
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:  this->use_previous_delta_max = true;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:    Real sigma_c = this->sigma_c;
solid_mechanics/solid_mechanics_model_cohesive/materials/constitutive_laws/material_cohesive_linear.cc:    this->computeTractionOnQuad(args);
solid_mechanics/materials/material_thermal.cc:      delta_T(this->registerInternal("delta_T", 1)),
solid_mechanics/materials/material_thermal.cc:      sigma_th(this->registerInternal("sigma_th", 1)) {
solid_mechanics/materials/material_thermal.cc:  this->registerParam("E", E, Real(0.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_thermal.cc:  this->registerParam("nu", nu, Real(0.5), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_thermal.cc:  this->registerParam("alpha", alpha, Real(0.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_thermal.cc:  this->registerParam("delta_T", delta_T, _pat_parsable | _pat_modifiable,
solid_mechanics/materials/weight_functions/remove_damaged_weight_function.hh:    this->registerParam("damage_limit", this->damage_limit, 1., _pat_parsable,
solid_mechanics/materials/weight_functions/remove_damaged_weight_function.hh:    this->init();
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    this->dir_vecs.emplace_back(std::make_unique<Vector<Real, dim>>());
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    auto && n = *this->dir_vecs.back();
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    this->registerParam("n" + std::to_string(i + 1), *(this->dir_vecs.back()),
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    if (this->symmetric) {
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:      this->registerParam(param, this->Cprime(i, j), Real(0.), _pat_parsmod,
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  if (this->symmetric) {
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:        this->Cprime(j, i) = this->Cprime(i, j);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  this->rotateCprime();
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  this->C.eig(this->eigC);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  this->was_stiffness_assembled = false;
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:      this->Cprime(i, j) = this->Cprime(i - diff, j);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:      this->Cprime(i, j) = this->Cprime(i, j - diff);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    auto && rot_vec = this->rot_mat(j);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    rot_vec = *this->dir_vecs[j];
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    v1.block<Dim, 1>(0, 0) = this->rot_mat(0);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    v2.block<Dim, 1>(0, 0) = this->rot_mat(1);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    Vector<Real, 3> v1 = this->rot_mat(0);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    Vector<Real, 3> v2 = this->rot_mat(1);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    Vector<Real, 3> v3 = this->rot_mat(2);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:          rotator(I, J) = this->rot_mat(k, i) * this->rot_mat(l, j);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:          revrotor(I, J) = this->rot_mat(i, k) * this->rot_mat(j, l);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:      this->C(i, j) = Cfull(i, j);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    this->computeStressOnQuad(data);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    this->computeTangentModuliOnQuad(args);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  this->was_stiffness_assembled = true;
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  AKANTU_DEBUG_ASSERT(!this->finite_deformation,
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    this->computePotentialEnergyOnQuad(std::get<0>(args), std::get<1>(args));
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  const auto & fem = this->getFEEngine();
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  auto gradu_view = make_view<dim, dim>(this->gradu(type));
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  auto stress_view = make_view<dim, dim>(this->stress(type));
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:    this->computePotentialEnergyOnQuad(data, data["Epot"_n]);
solid_mechanics/materials/material_elastic_linear_anisotropic.cc:  return std::sqrt(this->eigC(0) / rho);
solid_mechanics/materials/plane_stress_toolbox.hh:        "C33"_n = broadcast(C33, this->stress(el_type, ghost_type).size()));
solid_mechanics/materials/plane_stress_toolbox.hh:        "C33"_n = broadcast(C33, this->stress(el_type, ghost_type).size()));
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->registerParam("E1", E1, Real(0.), _pat_parsmod, "Young's modulus (n1)");
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->registerParam("E2", E2, Real(0.), _pat_parsmod, "Young's modulus (n2)");
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->registerParam("nu12", nu12, Real(0.), _pat_parsmod,
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->registerParam("G12", G12, Real(0.), _pat_parsmod, "Shear modulus (12)");
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->registerParam("E3", E3, Real(0.), _pat_parsmod,
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->registerParam("nu13", nu13, Real(0.), _pat_parsmod,
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->registerParam("nu23", nu23, Real(0.), _pat_parsmod,
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->registerParam("G13", G13, Real(0.), _pat_parsmod,
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->registerParam("G23", G23, Real(0.), _pat_parsmod,
solid_mechanics/materials/material_elastic_orthotropic.cc:  AKANTU_DEBUG_ASSERT(not this->finite_deformation,
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->C.zero();
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->Cprime.zero();
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->Cprime(0, 0) = E1 * (1 - nu23 * nu32) * Gamma;
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->Cprime(1, 1) = E2 * (1 - nu13 * nu31) * Gamma;
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->Cprime(2, 2) = E3 * (1 - nu12 * nu21) * Gamma;
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->Cprime(1, 0) = this->Cprime(0, 1) = E1 * (nu21 + nu31 * nu23) * Gamma;
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->Cprime(2, 0) = this->Cprime(0, 2) = E1 * (nu31 + nu21 * nu32) * Gamma;
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->Cprime(2, 1) = this->Cprime(1, 2) = E2 * (nu32 + nu12 * nu31) * Gamma;
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->Cprime(3, 3) = G23;
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->Cprime(4, 4) = G13;
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->Cprime(5, 5) = G12;
solid_mechanics/materials/material_elastic_orthotropic.cc:    this->Cprime(2, 2) = G12;
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->rotateCprime();
solid_mechanics/materials/material_elastic_orthotropic.cc:  this->C.eig(this->eigC);
diffusion_model/heat_transfer_model.hh:  [[nodiscard]] Array<Real> & getTemperature() { return this->getDiffusion(); }
diffusion_model/heat_transfer_model.hh:    return this->getDiffusion();
diffusion_model/heat_transfer_model.hh:    return this->getDiffusionRelease();
diffusion_model/heat_transfer_model.hh:    return this->getDiffusionRate();
diffusion_model/heat_transfer_model.hh:    return this->getExternalFlow();
diffusion_model/heat_transfer_model.hh:    return this->getExternalFlow();
diffusion_model/heat_transfer_model.hh:    return this->getInternalFlow();
diffusion_model/heat_diffusion.cc:  this->registerParam("density", density, _pat_parsmod);
diffusion_model/heat_diffusion.cc:  this->registerParam("conductivity", conductivity, _pat_parsmod);
diffusion_model/heat_diffusion.cc:  this->registerParam("conductivity_variation", conductivity_variation, 0.,
diffusion_model/heat_diffusion.cc:  this->registerParam("temperature_reference", T_ref, 0., _pat_parsmod);
diffusion_model/heat_diffusion.cc:  this->registerParam("capacity", capacity, _pat_parsmod);
diffusion_model/heat_diffusion.cc:  this->diffusivity.set(conductivity);
diffusion_model/heat_diffusion.cc:  this->computeDiffusivityOnQuadPoints(type, ghost_type);
diffusion_model/heat_diffusion.cc:  auto temperature_release = this->getHandler().getDiffusionRelease();
diffusion_model/heat_diffusion.cc:  auto & diffusivity_release = this->diffusivity.getRelease(type, ghost_type);
diffusion_model/heat_diffusion.cc:    this->getFEEngine().interpolateOnIntegrationPoints(
diffusion_model/heat_diffusion.cc:         zip(make_view<dim, dim>(this->diffusivity(type, ghost_type)),
diffusion_model/heat_diffusion.cc:  Real min_dt = 2. * element_size * element_size / 4. * this->density *
diffusion_model/heat_diffusion.cc:  this->getFEEngine().interpolateOnIntegrationPoints(
diffusion_model/heat_diffusion.cc:    this->getFEEngine().interpolateOnIntegrationPoints(
phase_field/phasefields/phasefield_quadratic_inline_impl.hh:    edis += 0.5 * g_c_quad * this->l0 * grad_d[i] * grad_d[i];
phase_field/phasefields/phasefield_quadratic_inline_impl.hh:  edis += g_c_quad * dam * dam / (2. * this->l0);
phase_field/phasefields/phasefield_quadratic_inline_impl.hh:  dam_energy_quad = 2.0 * phi_quad + g_c_quad / this->l0;
phase_field/phasefields/phasefield_quadratic_inline_impl.hh:  Real kpa = this->lambda + 2. * this->mu / Real(dev_dim);
phase_field/phasefields/phasefield_quadratic_inline_impl.hh:             this->mu * strain_dev.doubleDot(strain_dev);
phase_field/phasefields/phasefield_quadratic_inline_impl.hh:  phi_quad = 0.5 * this->lambda * trace * trace +
phase_field/phasefields/phasefield_quadratic_inline_impl.hh:             this->mu * strain_quad.doubleDot(strain_quad);
phase_field/phasefields/phasefield_quadratic.cc:  this->gamma = Real(this->g_c) / this->l0 * (1. / (tol_ir * tol_ir) - 1.);
phase_field/phasefields/phasefield_quadratic.cc:  this->dev_dim = dim;
phase_field/phasefields/phasefield_quadratic.cc:  if (dim == 2 && !this->plane_stress) {
phase_field/phasefields/phasefield_quadratic.cc:    this->dev_dim = 3;
phase_field/phasefields/phasefield_quadratic.cc:         zip(make_view(this->damage_energy(type, _not_ghost), dim, dim),
phase_field/phasefields/phasefield_quadratic.cc:             this->g_c(type, _not_ghost))) {
phase_field/phasefields/phasefield_quadratic.cc:          Matrix<Real>::Identity(dim, dim) * std::get<1>(tuple) * this->l0;
phase_field/phasefields/phasefield_quadratic.cc:  if (this->isotropic) {
phase_field/phasefields/phasefield_quadratic.cc:         zip(this->phi(el_type, ghost_type),
phase_field/phasefields/phasefield_quadratic.cc:             make_view(this->strain(el_type, ghost_type), dim, dim))) {
phase_field/phasefields/phasefield_quadratic.cc:         zip(this->phi(el_type, ghost_type),
phase_field/phasefields/phasefield_quadratic.cc:             make_view(this->strain(el_type, ghost_type), dim, dim))) {
phase_field/phasefields/phasefield_quadratic.cc:       zip(this->phi(el_type, ghost_type),
phase_field/phasefields/phasefield_quadratic.cc:           this->driving_force(el_type, ghost_type),
phase_field/phasefields/phasefield_quadratic.cc:           this->damage_energy_density(el_type, ghost_type),
phase_field/phasefields/phasefield_quadratic.cc:           this->damage_on_qpoints(el_type, _not_ghost),
phase_field/phasefields/phasefield_quadratic.cc:           make_view(this->driving_energy(el_type, ghost_type), dim),
phase_field/phasefields/phasefield_quadratic.cc:           make_view(this->damage_energy(el_type, ghost_type), dim, dim),
phase_field/phasefields/phasefield_quadratic.cc:           make_view(this->gradd(el_type, ghost_type), dim),
phase_field/phasefields/phasefield_quadratic.cc:           this->g_c(el_type, ghost_type),
phase_field/phasefields/phasefield_quadratic.cc:           this->damage_on_qpoints.previous(el_type, ghost_type))) {
phase_field/phasefields/phasefield_quadratic.cc:        this->gamma * std::min(Real(0.), dam_on_quad - dam_prev_quad);
phase_field/phasefields/phasefield_quadratic.cc:    dam_energy_density_quad += this->gamma * (dam_on_quad < dam_prev_quad);
phase_field/phasefields/phasefield_quadratic.cc:  for (auto && tuple : zip(this->dissipated_energy(el_type, _not_ghost),
phase_field/phasefields/phasefield_quadratic.cc:                           this->damage_on_qpoints(el_type, _not_ghost),
phase_field/phasefields/phasefield_quadratic.cc:                           make_view(this->gradd(el_type, _not_ghost), dim),
phase_field/phasefields/phasefield_quadratic.cc:                           this->g_c(el_type, _not_ghost))) {
phase_field/phasefields/phasefield_quadratic.cc:    this->computeDissipatedEnergyOnQuad(std::get<1>(tuple), std::get<2>(tuple),
phase_field/phasefields/phasefield_quadratic.cc:  auto gradd_it = this->gradd(type).begin(dim);
phase_field/phasefields/phasefield_quadratic.cc:  auto gradd_end = this->gradd(type).begin(dim);
phase_field/phasefields/phasefield_quadratic.cc:  auto damage_it = this->damage_on_qpoints(type).begin();
phase_field/phasefields/phasefield_quadratic.cc:  auto g_c_it = this->g_c(type).begin();
phase_field/phasefields/phasefield_quadratic.cc:  auto & fem = this->getFEEngine();
phase_field/phasefields/phasefield_quadratic.cc:    this->computeDissipatedEnergyOnQuad(*damage_it, *gradd_it, *edis_quad,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.hh:    Real dt = this->getModel().getTimeStep();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.hh:    return ((this->previous_dt == dt)
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.hh:                ? (!(this->previous_dt == dt)) * (this->was_stiffness_assembled)
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.hh:                : (!(this->previous_dt == dt)));
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.hh:    //  return (!(this->previous_dt == dt));
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:      stress_dev(this->registerInternal("stress_dev", dim * dim)),
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:      history_integral(this->registerInternal("history_integral", dim * dim)),
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:      dissipated_energy(this->registerInternal("dissipated_energy", 1)) {
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  this->registerParam("Eta", eta, Real(1.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  this->registerParam("Ev", Ev, Real(1.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  this->registerParam("Einf", E_inf, Real(1.), _pat_readable,
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  E_inf = this->E - this->Ev;
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  for (auto && args : this->getArguments(el_type, ghost_type)) {
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:    dev_s = 2 * this->mu *
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  Real dt = this->getModel().getTimeStep();
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto gamma_inf = E_inf / this->E;
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto gamma_v = Ev / this->E;
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto && arguments = this->getArguments(el_type, ghost_type);
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:    auto epsilon_d = this->template gradUToEpsilon<dim>(grad_u);
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:        Matrix<Real, dim, dim>::Identity() * gamma_inf * this->kpa * Theta;
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:    auto s = 2 * this->mu * epsilon_d;
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  this->updateDissipatedEnergy(el_type, ghost_type);
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto dt = this->getModel().getTimeStep();
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto gamma_v = Ev / this->E;
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto alpha = 1. / (2. * this->mu * gamma_v);
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:       zip(this->getArguments(el_type, ghost_type),
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  for (auto && type : this->getElementFilter().elementTypes(dim, _not_ghost)) {
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:                        this->getElementFilter(type, _not_ghost));
solid_mechanics/materials/material_viscoelastic/material_standard_linear_solid_deviatoric.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  this->registerParam("phi", phi, Real(0.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  this->registerParam("fc", fc, Real(1.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  this->registerParam("radial_return", radial_return_mapping, bool(true),
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  Real phi_radian = this->phi * M_PI / 180.;
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  this->alpha = (6. * sin(phi_radian)) / (3. - sin(phi_radian));
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  Real cohesion = this->fc * (1. - sin(phi_radian)) / (2. * cos(phi_radian));
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  this->k = (6. * cohesion * cos(phi_radian)) / (3. - sin(phi_radian));
solid_mechanics/materials/material_plastic/material_drucker_prager.cc:  if (this->finite_deformation) {
solid_mechanics/materials/material_plastic/material_plastic.hh:        "iso_hardening"_n = make_view(this->iso_hardening(el_type, ghost_type)),
solid_mechanics/materials/material_plastic/material_plastic.hh:            make_view(this->iso_hardening.previous(el_type, ghost_type)),
solid_mechanics/materials/material_plastic/material_plastic.hh:            make_view<dim, dim>(this->inelastic_strain(el_type, ghost_type)),
solid_mechanics/materials/material_plastic/material_plastic.hh:            this->inelastic_strain.previous(el_type, ghost_type)));
solid_mechanics/materials/material_plastic/material_drucker_prager_inline_impl.hh:  return this->alpha * sigma.trace() - this->k;
solid_mechanics/materials/material_plastic/material_drucker_prager_inline_impl.hh:  if (above_threshold(k, alpha) and this->alpha > 0) {
solid_mechanics/materials/material_plastic/material_drucker_prager_inline_impl.hh:      sigma_guess += -projection_error * 1. / this->alpha *
solid_mechanics/materials/material_plastic/material_drucker_prager_inline_impl.hh:  bool initial_yielding = (this->computeYieldFunction(sigma_tr) > 0);
solid_mechanics/materials/material_plastic/material_drucker_prager_inline_impl.hh:    this->computeGradientAndPlasticMultplier(sigma_tr, dp, gradient_f,
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening.cc:  if (this->finite_deformation) { // Finite deformation
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening.cc:             make_view<dim, dim>((*this->green_strain)(el_type, ghost_type)))) {
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening.cc:  this->was_stiffness_assembled = true;
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:      ((sigma_tr_dev_eff - iso_hardening - this->sigma_y) > 0);
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:                ? (sigma_tr_dev_eff - this->sigma_y - previous_iso_hardening) /
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:                      (3 * this->mu + this->h)
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:  iso_hardening = previous_iso_hardening + this->h * dp;
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:      ((cauchy_stress_dev_eff - iso_hardening - this->sigma_y) > 0);
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:                                      this->sigma_y) > Math::getTolerance()) {
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:    d_dp = (cauchy_stress_dev_eff - 3. * this->mu * dp - iso_hardening -
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:            this->sigma_y) /
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:           (3. * this->mu + this->h);
solid_mechanics/materials/material_plastic/material_linear_isotropic_hardening_inline_impl.hh:    iso_hardening = iso_hardening_t + this->h * dp;
solid_mechanics/materials/material_plastic/material_plastic.cc:      iso_hardening(this->registerInternal("iso_hardening", 1)),
solid_mechanics/materials/material_plastic/material_plastic.cc:      inelastic_strain(this->registerInternal("inelastic_strain", dim * dim)),
solid_mechanics/materials/material_plastic/material_plastic.cc:      plastic_energy(this->registerInternal("plastic_energy", 1)),
solid_mechanics/materials/material_plastic/material_plastic.cc:      d_plastic_energy(this->registerInternal("d_plastic_energy", 1)) {
solid_mechanics/materials/material_plastic/material_plastic.cc:  this->registerParam("h", h, Real(0.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_plastic/material_plastic.cc:  this->registerParam("sigma_y", sigma_y, Real(0.),
solid_mechanics/materials/material_plastic/material_plastic.cc:  this->iso_hardening.initializeHistory();
solid_mechanics/materials/material_plastic/material_plastic.cc:  this->inelastic_strain.initializeHistory();
solid_mechanics/materials/material_plastic/material_plastic.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_plastic/material_plastic.cc:       this->getElementFilter().elementTypes(dim, _not_ghost)) {
solid_mechanics/materials/material_plastic/material_plastic.cc:                             this->getElementFilter(type, _not_ghost));
solid_mechanics/materials/material_plastic/material_plastic.cc:       zip(getArguments(el_type), this->potential_energy(el_type))) {
solid_mechanics/materials/material_plastic/material_plastic.cc:                                 "pe"_n = this->plastic_energy(el_type),
solid_mechanics/materials/material_plastic/material_plastic.cc:                                 "wp"_n = this->d_plastic_energy(el_type))) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      dissipated_energy(this->registerInternal("dissipated_energy", 1)),
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      mechanical_work(this->registerInternal("mechanical_work", 1)) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->registerParam("Einf", Einf, Real(1.), _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->registerParam("previous_dt", previous_dt, Real(0.), _pat_readable,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->registerParam("Eta", Eta, _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->registerParam("Ev", Ev, _pat_parsable | _pat_modifiable,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->E = Einf + Ev.lpNorm<1>();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  AKANTU_DEBUG_ASSERT(this->Eta.size() == this->Ev.size(),
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      !this->finite_deformation,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->registerInternal("sigma_v", stress_size * this->Ev.size());
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->registerInternal("epsilon_v", stress_size * this->Ev.size());
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->sigma_v = this->getSharedPtrInternal("sigma_v");
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->epsilon_v = this->getSharedPtrInternal("epsilon_v");
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  [[maybe_unused]] auto pre_mult = 1 / (1 + this->nu) / (1 - 2 * this->nu);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  [[maybe_unused]] auto Miiii = pre_mult * (1 - this->nu);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  [[maybe_unused]] auto Miijj = pre_mult * this->nu;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  [[maybe_unused]] auto Mijij = pre_mult * 0.5 * (1 - 2 * this->nu);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  [[maybe_unused]] auto Diijj = -this->nu;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  [[maybe_unused]] auto Dijij = (2 + 2 * this->nu);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  Real dt = this->getModel().getTimeStep();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      this->Einf * this->C * voigt_current_strain;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      this->C * (voigt_current_strain - voigt_previous_strain);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (auto && [Eta, Ev, sigma] : zip(this->Eta, this->Ev, args["sigma_v"_n])) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:       zip(getArguments(el_type), this->potential_energy(el_type),
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:           make_view((*this->epsilon_v)(el_type), dim, dim, Eta.size()))) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    this->computePotentialEnergyOnQuad(args["grad_u"_n], epot,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      this->Einf * this->C * voigt_strain;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (Int k = 0; k < this->Eta.size(); ++k) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  if (this->update_variable_flag) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (const auto & el_type : this->getElementFilter().elementTypes(
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    this->updateDissipatedEnergy(el_type);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  Real dt = this->getModel().getTimeStep();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (Idx k = 0; k < this->Eta.size(); ++k) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    auto lambda = this->Eta(k) / this->Ev(k);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    Real E_ef_v = this->Ev(k);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:        exp_dt_lambda * voigt_sigma_v + E_ef_v * this->C * voigt_delta_strain;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    voigt_epsilon_v = 1 / Ev(k) * this->D * voigt_sigma_v;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  Real dt = this->getModel().getTimeStep();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  Real E_ef = this->Einf;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    Real lambda = this->Eta(k) / this->Ev(k);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      E_ef += this->Ev(k);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      E_ef += (1 - exp_dt_lambda) * this->Ev(k) * lambda / dt;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->previous_dt = dt;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    this->computeTangentModuliOnQuad(tangent);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->was_stiffness_assembled = true;
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (const auto & el_type : this->getElementFilter().elementTypes()) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:             make_view((*this->epsilon_v)(el_type), dim, dim, Eta.size()))) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  this->computePotentialEnergy(el_type);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:       zip(getArguments(el_type), this->potential_energy(el_type),
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:           this->dissipated_energy(el_type), this->mechanical_work(el_type))) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  Real dt = this->getModel().getTimeStep();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (auto && type : this->getElementFilter().elementTypes(dim, _not_ghost)) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    de += fem.integrate(this->dissipated_energy(type, _not_ghost), type,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:                        _not_ghost, this->getElementFilter(type, _not_ghost));
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      make_view(this->dissipated_energy(element.type), nb_quadrature_points)
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  mat_element.element = this->getElementFilter()(element);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (auto && type : this->getElementFilter().elementTypes(dim)) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    mw += fem.integrate(this->mechanical_work(type), type, _not_ghost,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:                        this->getElementFilter(type, _not_ghost));
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  auto it = make_view(this->mechanical_work(element.type), nb_quadrature_points)
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  mat_element.element = this->getElementFilter()(element);
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  for (auto && type : this->getElementFilter().elementTypes(dim, _not_ghost)) {
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:    epot += fem.integrate(this->potential_energy(type, _not_ghost), type,
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:                          _not_ghost, this->getElementFilter(type, _not_ghost));
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  auto & fem = this->getFEEngine();
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:      make_view(this->potential_energy(element.type), nb_quadrature_points)
solid_mechanics/materials/material_viscoelastic/material_viscoelastic_maxwell.cc:  mat_element.element = this->getElementFilter()(element);
phase_field/phasefields/phasefield_linear.cc:  this->gamma = Real(this->g_c) / this->l0 * 27. / (64. * tol_ir * tol_ir);
phase_field/phasefields/phasefield_linear.cc:  this->dev_dim = dim;
phase_field/phasefields/phasefield_linear.cc:  if (dim == 2 && !this->plane_stress) {
phase_field/phasefields/phasefield_linear.cc:    this->dim = 3;
phase_field/phasefields/phasefield_linear.cc:         zip(make_view(this->damage_energy(type, _not_ghost), dim, dim),
phase_field/phasefields/phasefield_linear.cc:             this->g_c(type, _not_ghost))) {
phase_field/phasefields/phasefield_linear.cc:      d.eye(3. / 4. * std::get<1>(tuple) * this->l0);
phase_field/phasefields/phasefield_linear.cc:  if (this->isotropic) {
phase_field/phasefields/phasefield_linear.cc:         zip(this->phi(el_type, ghost_type),
phase_field/phasefields/phasefield_linear.cc:             make_view(this->strain(el_type, ghost_type), dim, dim))) {
phase_field/phasefields/phasefield_linear.cc:         zip(this->phi(el_type, ghost_type),
phase_field/phasefields/phasefield_linear.cc:             make_view(this->strain(el_type, ghost_type), dim, dim))) {
phase_field/phasefields/phasefield_linear.cc:       zip(this->phi(el_type, ghost_type),
phase_field/phasefields/phasefield_linear.cc:           this->driving_force(el_type, ghost_type),
phase_field/phasefields/phasefield_linear.cc:           this->damage_energy_density(el_type, ghost_type),
phase_field/phasefields/phasefield_linear.cc:           this->damage_on_qpoints(el_type, _not_ghost),
phase_field/phasefields/phasefield_linear.cc:           make_view(this->driving_energy(el_type, ghost_type), dim),
phase_field/phasefields/phasefield_linear.cc:           make_view(this->damage_energy(el_type, ghost_type), dim, dim),
phase_field/phasefields/phasefield_linear.cc:           make_view(this->gradd(el_type, ghost_type), dim),
phase_field/phasefields/phasefield_linear.cc:           this->g_c(el_type, ghost_type),
phase_field/phasefields/phasefield_linear.cc:           this->damage_on_qpoints.previous(el_type, ghost_type))) {
phase_field/phasefields/phasefield_linear.cc:        this->gamma * std::min(Real(0.), dam_on_quad - dam_prev_quad);
phase_field/phasefields/phasefield_linear.cc:                         3 * g_c_quad / (8 * this->l0) + penalization;
phase_field/phasefields/phasefield_linear.cc:    dam_energy_density_quad += this->gamma * (dam_on_quad < dam_prev_quad);
phase_field/phasefields/phasefield_linear.cc:       zip(this->dissipated_energy(el_type, _not_ghost),
phase_field/phasefields/phasefield_linear.cc:           this->damage_on_qpoints(el_type, _not_ghost),
phase_field/phasefields/phasefield_linear.cc:           this->damage_on_qpoints.previous(el_type, _not_ghost),
phase_field/phasefields/phasefield_linear.cc:           make_view(this->gradd(el_type, _not_ghost), dim),
phase_field/phasefields/phasefield_linear.cc:           this->g_c(el_type, _not_ghost))) {
phase_field/phasefields/phasefield_linear.cc:    this->computeDissipatedEnergyOnQuad(std::get<1>(tuple), std::get<2>(tuple),
phase_field/phasefields/phasefield_linear.cc:  auto gradd_it = this->gradd(type).begin(dim);
phase_field/phasefields/phasefield_linear.cc:  auto gradd_end = this->gradd(type).begin(dim);
phase_field/phasefields/phasefield_linear.cc:  auto damage_it = this->damage_on_qpoints(type).begin();
phase_field/phasefields/phasefield_linear.cc:  auto damage_prev_it = this->damage_on_qpoints.previous(type).begin();
phase_field/phasefields/phasefield_linear.cc:  auto g_c_it = this->g_c(type).begin();
phase_field/phasefields/phasefield_linear.cc:  auto & fem = this->getFEEngine();
phase_field/phasefields/phasefield_linear.cc:    this->computeDissipatedEnergyOnQuad(*damage_it, *damage_prev_it, *gradd_it,
phase_field/phasefields/phasefield_linear.cc:  for (auto & dam : this->model.getDamage()) {
phase_field/phasefields/phasefield_exponential.cc:  this->dev_dim = dim;
phase_field/phasefields/phasefield_exponential.cc:  if (dim == 2 && !this->plane_stress) {
phase_field/phasefields/phasefield_exponential.cc:    this->dev_dim = 3;
phase_field/phasefields/phasefield_exponential.cc:         zip(make_view<dim, dim>(this->damage_energy(type, _not_ghost)),
phase_field/phasefields/phasefield_exponential.cc:             this->g_c(type, _not_ghost))) {
phase_field/phasefields/phasefield_exponential.cc:      dam = Matrix<Real, dim, dim>::Identity() * gc * this->l0;
phase_field/phasefields/phasefield_exponential.cc:      this->phi(el_type, ghost_type), this->phi.previous(el_type, ghost_type),
phase_field/phasefields/phasefield_exponential.cc:      make_view(this->strain(el_type, ghost_type), dim, dim));
phase_field/phasefields/phasefield_exponential.cc:  if (this->isotropic) {
phase_field/phasefields/phasefield_exponential.cc:       zip(this->phi(el_type, ghost_type),
phase_field/phasefields/phasefield_exponential.cc:           this->driving_force(el_type, ghost_type),
phase_field/phasefields/phasefield_exponential.cc:           this->damage_energy_density(el_type, ghost_type),
phase_field/phasefields/phasefield_exponential.cc:           this->damage_on_qpoints(el_type, _not_ghost),
phase_field/phasefields/phasefield_exponential.cc:           make_view(this->driving_energy(el_type, ghost_type), dim),
phase_field/phasefields/phasefield_exponential.cc:           make_view(this->damage_energy(el_type, ghost_type), dim, dim),
phase_field/phasefields/phasefield_exponential.cc:           make_view(this->gradd(el_type, ghost_type), dim),
phase_field/phasefields/phasefield_exponential.cc:           this->g_c(el_type, ghost_type))) {
phase_field/phasefields/phasefield_exponential.cc:       zip(this->dissipated_energy(el_type, _not_ghost),
phase_field/phasefields/phasefield_exponential.cc:           this->damage_on_qpoints(el_type, _not_ghost),
phase_field/phasefields/phasefield_exponential.cc:           make_view<dim>(this->gradd(el_type, _not_ghost)),
phase_field/phasefields/phasefield_exponential.cc:           this->g_c(el_type, _not_ghost))) {
phase_field/phasefields/phasefield_exponential.cc:    this->computeDissipatedEnergyOnQuad(damage, grad_d, dis_energy, g_c);
phase_field/phasefields/phasefield_exponential.cc:  auto && fem = this->getFEEngine();
phase_field/phasefields/phasefield_exponential.cc:  auto gradd_it = make_view<dim>(this->gradd(type)).begin() + quad;
phase_field/phasefields/phasefield_exponential.cc:  auto damage_it = this->damage_on_qpoints(type).begin() + quad;
phase_field/phasefields/phasefield_exponential.cc:  auto g_c_it = this->g_c(type).begin() + quad;
phase_field/phasefields/phasefield_exponential.cc:    this->computeDissipatedEnergyOnQuad(*damage_it, *gradd_it, *edis_quad,
phase_field/phasefields/phasefield_exponential_inline_impl.hh:    edis += 0.5 * g_c_quad * this->l0 * grad_d[i] * grad_d[i];
phase_field/phasefields/phasefield_exponential_inline_impl.hh:  edis += g_c_quad * dam * dam / (2. * this->l0);
phase_field/phasefields/phasefield_exponential_inline_impl.hh:  dam_energy_quad = 2.0 * phi_quad + g_c_quad / this->l0;
phase_field/phasefields/phasefield_exponential_inline_impl.hh:  Real kpa = this->lambda + 2. * this->mu / Real(dev_dim);
phase_field/phasefields/phasefield_exponential_inline_impl.hh:             this->mu * strain_dev.doubleDot(strain_dev);
phase_field/phasefields/phasefield_exponential_inline_impl.hh:  phi_quad = 0.5 * this->lambda * trace * trace +
phase_field/phasefields/phasefield_exponential_inline_impl.hh:             this->mu * strain_quad.doubleDot(strain_quad);
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  // this->registerParam("ft", this->ft, 0., _pat_parsable, "Tensile strength");
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  // const Mesh & mesh = this->material.getModel().getFEEngine().getMesh();
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  // 	this->material.getModel().getFEEngine().getNbQuadraturePoints(*it, gt);
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  //     this->material.getElementFilter(*it, gt);
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  //     this->material.getModel().getFEEngine().integrateOnQuadraturePoints(ones,
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  //   const Mesh & mesh = this->material.getModel().getFEEngine().getMesh();
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  //       this->material.getStress(*it, ghost_type).begin(spatial_dimension,
solid_mechanics/materials/weight_functions/stress_based_weight_function.cc:  //         (*eigenvalues)(i) = std::max(*cl / this->R, (*eigenvalues)(i));
contact_mechanics/contact_detector.cc:  this->spatial_dimension = mesh.getSpatialDimension();
contact_mechanics/contact_detector.cc:  this->positions.copy(positions);
contact_mechanics/contact_detector.cc:  this->parseSection(section);
contact_mechanics/contact_detector.cc:    this->detection_type = _implicit;
contact_mechanics/contact_detector.cc:    this->detection_type = _explicit;
contact_mechanics/contact_detector.cc:  this->projection_tolerance =
contact_mechanics/contact_detector.cc:  this->max_iterations = section.getParameterValue<Int>("max_iterations");
contact_mechanics/contact_detector.cc:  this->extension_tolerance =
contact_mechanics/contact_detector.cc:  this->mesh.fillNodesToElements(surface_dimension);
contact_mechanics/contact_detector.cc:  this->computeMaximalDetectionDistance();
contact_mechanics/contact_detector.cc:  auto && [bbox, master_grid] = this->globalSearch();
contact_mechanics/contact_detector.cc:  this->localSearch(bbox, *master_grid);
contact_mechanics/contact_detector.cc:  this->createContactElements(elements, gaps, normals, tangents, projections);
contact_mechanics/contact_detector.cc:  this->constructBoundingBox(bbox_master, master_list);
contact_mechanics/contact_detector.cc:  this->constructBoundingBox(bbox_slave, slave_list);
contact_mechanics/contact_detector.cc:  this->computeCellSpacing(spacing);
contact_mechanics/contact_detector.cc:  this->constructGrid(*master_grid, bbox_intersection, master_list);
contact_mechanics/contact_detector.cc:  // this->constructGrid(slave_grid, bbox_intersection, slave_list);
contact_mechanics/contact_detector.cc:        auto && elements = this->mesh.getAssociatedElements(slave_node);
contact_mechanics/contact_detector.cc:          const auto & connectivity = this->mesh.getConnectivity(elem);
contact_mechanics/contact_detector.cc:    auto && elements = this->mesh.getAssociatedElements(master_node);
contact_mechanics/contact_detector.cc:        alpha, this->max_iterations, this->projection_tolerance,
contact_mechanics/contact_detector.cc:        this->extension_tolerance);
contact_mechanics/resolution.cc:  this->initialize();
contact_mechanics/resolution.cc:  this->assembleInternalForces();
contact_mechanics/surface_selector.cc:  this->mesh.registerEventHandler(*this, _ehp_lowest);
contact_mechanics/surface_selector.cc:  this->mesh.registerEventHandler(*this, _ehp_lowest);
contact_mechanics/surface_selector.cc:  auto surface_dimension = this->mesh.getSpatialDimension() - 1;
contact_mechanics/contact_mechanics_model.cc:  this->initDOFManager(dof_manager);
contact_mechanics/contact_mechanics_model.cc:  this->registerFEEngineObject<MyFEEngineType>("ContactMechanicsModel", mesh,
contact_mechanics/contact_mechanics_model.cc:  this->mesh.registerDumper<DumperParaview>("contact_mechanics", id, true);
contact_mechanics/contact_mechanics_model.cc:  this->mesh.addDumpMeshToDumper("contact_mechanics", mesh,
contact_mechanics/contact_mechanics_model.cc:  this->registerDataAccessor(*this);
contact_mechanics/contact_mechanics_model.cc:  this->detector =
contact_mechanics/contact_mechanics_model.cc:      std::make_unique<ContactDetector>(this->mesh, id + ":contact_detector");
contact_mechanics/contact_mechanics_model.cc:  if (not this->parser.getLastParsedFile().empty()) {
contact_mechanics/contact_mechanics_model.cc:    this->instantiateResolutions();
contact_mechanics/contact_mechanics_model.cc:    this->initResolutions();
contact_mechanics/contact_mechanics_model.cc:  this->initBC(*this, *displacement, *displacement_increment, *external_force);
contact_mechanics/contact_mechanics_model.cc:  std::tie(model_section, is_empty) = this->getParserSection();
contact_mechanics/contact_mechanics_model.cc:      this->registerNewResolution(section);
contact_mechanics/contact_mechanics_model.cc:      this->parser.getSubSections(ParserType::_contact_resolution);
contact_mechanics/contact_mechanics_model.cc:    this->registerNewResolution(section);
contact_mechanics/contact_mechanics_model.cc:  Resolution & res = this->registerNewResolution(res_name, res_type, opt_param);
contact_mechanics/contact_mechanics_model.cc:  sstr_res << this->id << ":" << res_count << ":" << res_type;
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->displacement, spatial_dimension, "displacement");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->displacement_increment, spatial_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->internal_force, spatial_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->external_force, spatial_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->normal_force, spatial_dimension, "normal_force");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->tangential_force, spatial_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->gaps, 1, "gaps");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->nodal_area, 1, "areas");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->blocked_dofs, 1, "blocked_dofs");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->contact_state, 1, "contact_state");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->previous_master_elements, 1,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->normals, spatial_dimension, "normals");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->tangents, surface_dimension * spatial_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->projections, surface_dimension, "projections");
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->previous_projections, surface_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->previous_tangents,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->tangential_tractions, surface_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->allocNodalField(this->previous_tangential_tractions, surface_dimension,
contact_mechanics/contact_mechanics_model.cc:  this->assembleInternalForces();
contact_mechanics/contact_mechanics_model.cc:  this->getDOFManager().assembleToResidual("displacement",
contact_mechanics/contact_mechanics_model.cc:                                           *this->internal_force, 1);
contact_mechanics/contact_mechanics_model.cc:  this->internal_force->clear();
contact_mechanics/contact_mechanics_model.cc:  this->normal_force->clear();
contact_mechanics/contact_mechanics_model.cc:  this->tangential_force->clear();
contact_mechanics/contact_mechanics_model.cc:  this->savePreviousState();
contact_mechanics/contact_mechanics_model.cc:  this->detector->search(contact_elements, *gaps, *normals, *tangents,
contact_mechanics/contact_mechanics_model.cc:    this->computeNodalAreas();
contact_mechanics/contact_mechanics_model.cc:    this->getDOFManager().assembleElementalArrayLocalArray(
contact_mechanics/contact_mechanics_model.cc:  this->external_force->clear();
contact_mechanics/contact_mechanics_model.cc:    this->assembleStiffnessMatrix();
contact_mechanics/contact_mechanics_model.cc:  if (!this->getDOFManager().hasMatrix("K")) {
contact_mechanics/contact_mechanics_model.cc:    this->getDOFManager().getNewMatrix("K", getMatrixType("K"));
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["contact_force"] = this->internal_force.get();
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["normal_force"] = this->normal_force.get();
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["tangential_force"] = this->tangential_force.get();
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["normals"] = this->normals.get();
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["tangents"] = this->tangents.get();
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["gaps"] = this->gaps.get();
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["areas"] = this->nodal_area.get();
contact_mechanics/contact_mechanics_model.cc:  real_nodal_fields["tangential_traction"] = this->tangential_tractions.get();
contact_mechanics/contact_mechanics_model.cc:    field = this->mesh.createNodalField(real_nodal_fields[field_name],
contact_mechanics/contact_mechanics_model.cc:        this->mesh.createNodalField(real_nodal_fields[field_name], group_name);
contact_mechanics/contact_mechanics_model.cc:    field = mesh.createNodalField(this->contact_state.get(), group_name);
contact_mechanics/resolutions/resolution_penalty_quadratic.cc:  this->initialize();
contact_mechanics/resolutions/resolution_penalty.cc:  this->initialize();
contact_mechanics/resolutions/resolution_penalty.cc:  this->registerParam("epsilon_n", epsilon_n, Real(0.),
contact_mechanics/resolutions/resolution_penalty.cc:  this->registerParam("epsilon_t", epsilon_t, Real(0.),
contact_mechanics/resolutions/resolution_penalty.cc:  this->computeTangentialTraction(element, covariant_basis,
contact_mechanics/resolutions/resolution_penalty.cc:  this->computeTrialTangentialTraction(element, covariant_basis,
contact_mechanics/contact_detector_inline_impl.hh:  auto position_it = make_view(this->positions, spatial_dimension).begin();
contact_mechanics/contact_detector_inline_impl.hh:    auto && pos = make_view(this->positions, spatial_dimension).begin()[node];
contact_mechanics/contact_detector_inline_impl.hh:  auto & master_nodes = this->surface_selector->getMasterList();
contact_mechanics/contact_detector_inline_impl.hh:    this->mesh.getAssociatedElements(master, elements);
contact_mechanics/contact_detector_inline_impl.hh:      this->coordinatesOfElement(element, elem_coords);
contact_mechanics/contact_detector_inline_impl.hh:  this->min_dd = min_elem_size;
contact_mechanics/contact_detector_inline_impl.hh:  this->max_dd = max_elem_size;
contact_mechanics/contact_detector_inline_impl.hh:  this->max_bb = max_elem_size;
contact_mechanics/contact_detector_inline_impl.hh:  auto && master_conn = this->mesh.getConnectivity(master);
contact_mechanics/contact_detector_inline_impl.hh:  this->vectorsAlongElement(element, vectors);
contact_mechanics/contact_detector_inline_impl.hh:  switch (this->spatial_dimension) {
contact_mechanics/contact_detector_inline_impl.hh:  this->coordinatesOfElement(el, coords);
contact_mechanics/contact_detector_inline_impl.hh:  auto && slave_elements = this->mesh.getAssociatedElements(slave_node);
contact_mechanics/contact_detector_inline_impl.hh:    auto && connectivity = this->mesh.getConnectivity(element);
